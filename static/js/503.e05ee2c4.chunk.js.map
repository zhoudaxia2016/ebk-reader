{"version":3,"file":"static/js/503.e05ee2c4.chunk.js","mappings":"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","sources":["foliate-js/search.js"],"sourcesContent":["// length for context in excerpts\nconst CONTEXT_LENGTH = 50\n\nconst normalizeWhitespace = str => str.replace(/\\s+/g, ' ')\n\nconst makeExcerpt = (strs, { startIndex, startOffset, endIndex, endOffset }) => {\n    const start = strs[startIndex]\n    const end = strs[endIndex]\n    const match = start === end\n        ? start.slice(startOffset, endOffset)\n        : start.slice(startOffset)\n            + strs.slice(start + 1, end).join('')\n            + end.slice(0, endOffset)\n    const trimmedStart = normalizeWhitespace(start.slice(0, startOffset)).trimStart()\n    const trimmedEnd = normalizeWhitespace(end.slice(endOffset)).trimEnd()\n    const ellipsisPre = trimmedStart.length < CONTEXT_LENGTH ? '' : '…'\n    const ellipsisPost = trimmedEnd.length < CONTEXT_LENGTH ? '' : '…'\n    const pre = `${ellipsisPre}${trimmedStart.slice(-CONTEXT_LENGTH)}`\n    const post = `${trimmedEnd.slice(0, CONTEXT_LENGTH)}${ellipsisPost}`\n    return { pre, match, post }\n}\n\nconst simpleSearch = function* (strs, query, options = {}) {\n    const { locales = 'en', sensitivity } = options\n    const matchCase = sensitivity === 'variant'\n    const haystack = strs.join('')\n    const lowerHaystack = matchCase ? haystack : haystack.toLocaleLowerCase(locales)\n    const needle = matchCase ? query : query.toLocaleLowerCase(locales)\n    const needleLength = needle.length\n    let index = -1\n    let strIndex = -1\n    let sum = 0\n    do {\n        index = lowerHaystack.indexOf(needle, index + 1)\n        if (index > -1) {\n            while (sum <= index) sum += strs[++strIndex].length\n            const startIndex = strIndex\n            const startOffset = index - (sum - strs[strIndex].length)\n            const end = index + needleLength\n            while (sum <= end) sum += strs[++strIndex].length\n            const endIndex = strIndex\n            const endOffset = end - (sum - strs[strIndex].length)\n            const range = { startIndex, startOffset, endIndex, endOffset }\n            yield { range, excerpt: makeExcerpt(strs, range) }\n        }\n    } while (index > -1)\n}\n\nconst segmenterSearch = function* (strs, query, options = {}) {\n    const { locales = 'en', granularity = 'word', sensitivity = 'base' } = options\n    let segmenter, collator\n    try {\n        segmenter = new Intl.Segmenter(locales, { usage: 'search', granularity })\n        collator = new Intl.Collator(locales, { sensitivity })\n    } catch (e) {\n        console.warn(e)\n        segmenter = new Intl.Segmenter('en', { usage: 'search', granularity })\n        collator = new Intl.Collator('en', { sensitivity })\n    }\n    const queryLength = Array.from(segmenter.segment(query)).length\n\n    const substrArr = []\n    let strIndex = 0\n    let segments = segmenter.segment(strs[strIndex])[Symbol.iterator]()\n    main: while (strIndex < strs.length) {\n        while (substrArr.length < queryLength) {\n            const { done, value } = segments.next()\n            if (done) {\n                // the current string is exhausted\n                // move on to the next string\n                strIndex++\n                if (strIndex < strs.length) {\n                    segments = segmenter.segment(strs[strIndex])[Symbol.iterator]()\n                    continue\n                } else break main\n            }\n            const { index, segment } = value\n            // ignore formatting characters\n            if (!/[^\\p{Format}]/u.test(segment)) continue\n            // normalize whitespace\n            if (/\\s/u.test(segment)) {\n                if (!/\\s/u.test(substrArr[substrArr.length - 1]?.segment))\n                    substrArr.push({ strIndex, index, segment: ' ' })\n                continue\n            }\n            value.strIndex = strIndex\n            substrArr.push(value)\n        }\n        const substr = substrArr.map(x => x.segment).join('')\n        if (collator.compare(query, substr) === 0) {\n            const endIndex = strIndex\n            const lastSeg = substrArr[substrArr.length - 1]\n            const endOffset = lastSeg.index + lastSeg.segment.length\n            const startIndex = substrArr[0].strIndex\n            const startOffset = substrArr[0].index\n            const range = { startIndex, startOffset, endIndex, endOffset }\n            yield { range, excerpt: makeExcerpt(strs, range) }\n        }\n        substrArr.shift()\n    }\n}\n\nexport const search = (strs, query, options) => {\n    const { granularity = 'grapheme', sensitivity = 'base' } = options\n    if (!Intl?.Segmenter || granularity === 'grapheme'\n    && (sensitivity === 'variant' || sensitivity === 'accent'))\n        return simpleSearch(strs, query, options)\n    return segmenterSearch(strs, query, options)\n}\n\nexport const searchMatcher = (textWalker, opts) => {\n    const { defalutLocale, matchCase, matchDiacritics, matchWholeWords } = opts\n    return function* (doc, query) {\n        const iter = textWalker(doc, function* (strs, makeRange) {\n            for (const result of search(strs, query, {\n                locales: doc.body.lang || doc.documentElement.lang || defalutLocale || 'en',\n                granularity: matchWholeWords ? 'word' : 'grapheme',\n                sensitivity: matchDiacritics && matchCase ? 'variant'\n                : matchDiacritics && !matchCase ? 'accent'\n                : !matchDiacritics && matchCase ? 'case'\n                : 'base',\n            })) {\n                const { startIndex, startOffset, endIndex, endOffset } = result.range\n                result.range = makeRange(startIndex, startOffset, endIndex, endOffset)\n                yield result\n            }\n        })\n        for (const result of iter) yield result\n    }\n}\n"],"names":["normalizeWhitespace","str","replace","makeExcerpt","strs","_ref","startIndex","startOffset","endIndex","endOffset","start","end","match","slice","join","trimmedStart","trimStart","trimmedEnd","trimEnd","ellipsisPre","length","ellipsisPost","pre","concat","post","search","query","options","_Intl","granularity","sensitivity","Intl","Segmenter","arguments","undefined","locales","segmenter","collator","usage","Collator","e","console","warn","queryLength","Array","from","segment","substrArr","strIndex","segments","Symbol","iterator","main","done","value","next","index","_substrArr","test","push","substr","map","x","compare","lastSeg","range","excerpt","shift","segmenterSearch","matchCase","haystack","lowerHaystack","toLocaleLowerCase","needle","needleLength","sum","indexOf","simpleSearch","searchMatcher","textWalker","opts","defalutLocale","matchDiacritics","matchWholeWords","doc","iter","makeRange","result","body","lang","documentElement"],"sourceRoot":""}