{"version":3,"file":"static/js/896.a8ac5f3d.chunk.js","mappings":"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","sources":["../node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js","../node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js","foliate-js/epubcfi.js","foliate-js/epub.js"],"sourcesContent":["function _classPrivateFieldBase(e, t) {\n  if (!{}.hasOwnProperty.call(e, t)) throw new TypeError(\"attempted to use private field on non-instance\");\n  return e;\n}\nexport { _classPrivateFieldBase as default };","var id = 0;\nfunction _classPrivateFieldKey(e) {\n  return \"__private_\" + id++ + \"_\" + e;\n}\nexport { _classPrivateFieldKey as default };","const findIndices = (arr, f) => arr\n    .map((x, i, a) => f(x, i, a) ? i : null).filter(x => x != null)\nconst splitAt = (arr, is) => [-1, ...is, arr.length].reduce(({ xs, a }, b) =>\n    ({ xs: xs?.concat([arr.slice(a + 1, b)]) ?? [], a: b }), {}).xs\nconst concatArrays = (a, b) =>\n    a.slice(0, -1).concat([a[a.length - 1].concat(b[0])]).concat(b.slice(1))\n\nconst isNumber = /\\d/\nexport const isCFI = /^epubcfi\\((.*)\\)$/\nconst escapeCFI = str => str.replace(/[\\^[\\](),;=]/g, '^$&')\n\nconst wrap = x => isCFI.test(x) ? x : `epubcfi(${x})`\nconst unwrap = x => x.match(isCFI)?.[1] ?? x\nconst lift = f => (...xs) =>\n    `epubcfi(${f(...xs.map(x => x.match(isCFI)?.[1] ?? x))})`\nexport const joinIndir = lift((...xs) => xs.join('!'))\n\nconst tokenizer = str => {\n    const tokens = []\n    let state, escape, value = ''\n    const push = x => (tokens.push(x), state = null, value = '')\n    const cat = x => (value += x, escape = false)\n    for (const char of Array.from(str.trim()).concat('')) {\n        if (char === '^' && !escape) {\n            escape = true\n            continue\n        }\n        if (state === '!') push(['!'])\n        else if (state === ',') push([','])\n        else if (state === '/' || state === ':') {\n            if (isNumber.test(char)) {\n                cat(char)\n                continue\n            } else push([state, parseInt(value)])\n        } else if (state === '~') {\n            if (isNumber.test(char) || char === '.') {\n                cat(char)\n                continue\n            } else push(['~', parseFloat(value)])\n        } else if (state === '@') {\n            if (char === ':') {\n                push(['@', parseFloat(value)])\n                state = '@'\n                continue\n            }\n            if (isNumber.test(char) || char === '.') {\n                cat(char)\n                continue\n            } else push(['@', parseFloat(value)])\n        } else if (state === '[') {\n            if (char === ';' && !escape) {\n                push(['[', value])\n                state = ';'\n            } else if (char === ',' && !escape) {\n                push(['[', value])\n                state = '['\n            } else if (char === ']' && !escape) push(['[', value])\n            else cat(char)\n            continue\n        } else if (state?.startsWith(';')) {\n            if (char === '=' && !escape) {\n                state = `;${value}`\n                value = ''\n            } else if (char === ';' && !escape) {\n                push([state, value])\n                state = ';'\n            } else if (char === ']' && !escape) push([state, value])\n            else cat(char)\n            continue\n        }\n        if (char === '/' || char === ':' || char === '~' || char === '@'\n        || char === '[' || char === '!' || char === ',') state = char\n    }\n    return tokens\n}\n\nconst findTokens = (tokens, x) => findIndices(tokens, ([t]) => t === x)\n\nconst parser = tokens => {\n    const parts = []\n    let state\n    for (const [type, val] of tokens) {\n        if (type === '/') parts.push({ index: val })\n        else {\n            const last = parts[parts.length - 1]\n            if (type === ':') last.offset = val\n            else if (type === '~') last.temporal = val\n            else if (type === '@') last.spatial = (last.spatial ?? []).concat(val)\n            else if (type === ';s') last.side = val\n            else if (type === '[') {\n                if (state === '/' && val) last.id = val\n                else {\n                    last.text = (last.text ?? []).concat(val)\n                    continue\n                }\n            }\n        }\n        state = type\n    }\n    return parts\n}\n\n// split at step indirections, then parse each part\nconst parserIndir = tokens =>\n    splitAt(tokens, findTokens(tokens, '!')).map(parser)\n\nexport const parse = cfi => {\n    const tokens = tokenizer(unwrap(cfi))\n    const commas = findTokens(tokens, ',')\n    if (!commas.length) return parserIndir(tokens)\n    const [parent, start, end] = splitAt(tokens, commas).map(parserIndir)\n    return { parent, start, end }\n}\n\nconst partToString = ({ index, id, offset, temporal, spatial, text, side }) => {\n    const param = side ? `;s=${side}` : ''\n    return `/${index}`\n        + (id ? `[${escapeCFI(id)}${param}]` : '')\n        // \"CFI expressions [..] SHOULD include an explicit character offset\"\n        + (offset != null && index % 2 ? `:${offset}` : '')\n        + (temporal ? `~${temporal}` : '')\n        + (spatial ? `@${spatial.join(':')}` : '')\n        + (text || (!id && side) ? '['\n            + (text?.map(escapeCFI)?.join(',') ?? '')\n            + param + ']' : '')\n}\n\nconst toInnerString = parsed => parsed.parent\n    ? [parsed.parent, parsed.start, parsed.end].map(toInnerString).join(',')\n    : parsed.map(parts => parts.map(partToString).join('')).join('!')\n\nconst toString = parsed => wrap(toInnerString(parsed))\n\nexport const collapse = (x, toEnd) => typeof x === 'string'\n    ? toString(collapse(parse(x), toEnd))\n    : x.parent ? concatArrays(x.parent, x[toEnd ? 'end' : 'start']) : x\n\n// create range CFI from two CFIs\nconst buildRange = (from, to) => {\n    if (typeof from === 'string') from = parse(from)\n    if (typeof to === 'string') to = parse(to)\n    from = collapse(from)\n    to = collapse(to, true)\n    // ranges across multiple documents are not allowed; handle local paths only\n    const localFrom = from[from.length - 1], localTo = to[to.length - 1]\n    const localParent = [], localStart = [], localEnd = []\n    let pushToParent = true\n    const len = Math.max(localFrom.length, localTo.length)\n    for (let i = 0; i < len; i++) {\n        const a = localFrom[i], b = localTo[i]\n        pushToParent &&= a?.index === b?.index && !a?.offset && !b?.offset\n        if (pushToParent) localParent.push(a)\n        else {\n            if (a) localStart.push(a)\n            if (b) localEnd.push(b)\n        }\n    }\n    // copy non-local paths from `from`\n    const parent = from.slice(0, -1).concat([localParent])\n    return toString({ parent, start: [localStart], end: [localEnd] })\n}\n\nexport const compare = (a, b) => {\n    if (typeof a === 'string') a = parse(a)\n    if (typeof b === 'string') b = parse(b)\n    if (a.start || b.start) return compare(collapse(a), collapse(b))\n        || compare(collapse(a, true), collapse(b, true))\n\n    for (let i = 0; i < Math.max(a.length, b.length); i++) {\n        const p = a[i], q = b[i]\n        const maxIndex = Math.max(p.length, q.length) - 1\n        for (let i = 0; i <= maxIndex; i++) {\n            const x = p[i], y = q[i]\n            if (!x) return -1\n            if (!y) return 1\n            if (x.index > y.index) return 1\n            if (x.index < y.index) return -1\n            if (i === maxIndex) {\n                // TODO: compare temporal & spatial offsets\n                if (x.offset > y.offset) return 1\n                if (x.offset < y.offset) return -1\n            }\n        }\n    }\n    return 0\n}\n\nconst isTextNode = ({ nodeType }) => nodeType === 3 || nodeType === 4\nconst isElementNode = ({ nodeType }) => nodeType === 1\n\nconst getChildNodes = (node, filter) => {\n    const nodes = Array.from(node.childNodes)\n        // \"content other than element and character data is ignored\"\n        .filter(node => isTextNode(node) || isElementNode(node))\n    return filter ? nodes.map(node => {\n        const accept = filter(node)\n        if (accept === NodeFilter.FILTER_REJECT) return null\n        else if (accept === NodeFilter.FILTER_SKIP) return getChildNodes(node, filter)\n        else return node\n    }).flat().filter(x => x) : nodes\n}\n\n// child nodes are organized such that the result is always\n//     [element, text, element, text, ..., element],\n// regardless of the actual structure in the document;\n// so multiple text nodes need to be combined, and nonexistent ones counted;\n// see \"Step Reference to Child Element or Character Data (/)\" in EPUB CFI spec\nconst indexChildNodes = (node, filter) => {\n    const nodes = getChildNodes(node, filter)\n        .reduce((arr, node) => {\n            let last = arr[arr.length - 1]\n            if (!last) arr.push(node)\n            // \"there is one chunk between each pair of child elements\"\n            else if (isTextNode(node)) {\n                if (Array.isArray(last)) last.push(node)\n                else if (isTextNode(last)) arr[arr.length - 1] = [last, node]\n                else arr.push(node)\n            } else {\n                if (isElementNode(last)) arr.push(null, node)\n                else arr.push(node)\n            }\n            return arr\n        }, [])\n    // \"the first chunk is located before the first child element\"\n    if (isElementNode(nodes[0])) nodes.unshift('first')\n    // \"the last chunk is located after the last child element\"\n    if (isElementNode(nodes[nodes.length - 1])) nodes.push('last')\n    // \"'virtual' elements\"\n    nodes.unshift('before') // \"0 is a valid index\"\n    nodes.push('after') // \"n+2 is a valid index\"\n    return nodes\n}\n\nconst partsToNode = (node, parts, filter) => {\n    const { id } = parts[parts.length - 1]\n    if (id) {\n        const el = node.ownerDocument.getElementById(id)\n        if (el) return { node: el, offset: 0 }\n    }\n    for (const { index } of parts) {\n        const newNode = node ? indexChildNodes(node, filter)[index] : null\n        // handle non-existent nodes\n        if (newNode === 'first') return { node: node.firstChild ?? node }\n        if (newNode === 'last') return { node: node.lastChild ?? node }\n        if (newNode === 'before') return { node, before: true }\n        if (newNode === 'after') return { node, after: true }\n        node = newNode\n    }\n    const { offset } = parts[parts.length - 1]\n    if (!Array.isArray(node)) return { node, offset }\n    // get underlying text node and offset from the chunk\n    let sum = 0\n    for (const n of node) {\n        const { length } = n.nodeValue\n        if (sum + length >= offset) return { node: n, offset: offset - sum }\n        sum += length\n    }\n}\n\nconst nodeToParts = (node, offset, filter) => {\n    const { parentNode, id } = node\n    const indexed = indexChildNodes(parentNode, filter)\n    const index = indexed.findIndex(x =>\n        Array.isArray(x) ? x.some(x => x === node) : x === node)\n    // adjust offset as if merging the text nodes in the chunk\n    const chunk = indexed[index]\n    if (Array.isArray(chunk)) {\n        let sum = 0\n        for (const x of chunk) {\n            if (x === node) {\n                sum += offset\n                break\n            } else sum += x.nodeValue.length\n        }\n        offset = sum\n    }\n    const part = { id, index, offset }\n    return (parentNode !== node.ownerDocument.documentElement\n        ? nodeToParts(parentNode, null, filter).concat(part) : [part])\n        // remove ignored nodes\n        .filter(x => x.index !== -1)\n}\n\nexport const fromRange = (range, filter) => {\n    const { startContainer, startOffset, endContainer, endOffset } = range\n    const start = nodeToParts(startContainer, startOffset, filter)\n    if (range.collapsed) return toString([start])\n    const end = nodeToParts(endContainer, endOffset, filter)\n    return buildRange([start], [end])\n}\n\nexport const toRange = (doc, parts, filter) => {\n    const startParts = collapse(parts)\n    const endParts = collapse(parts, true)\n\n    const root = doc.documentElement\n    const start = partsToNode(root, startParts[0], filter)\n    const end = partsToNode(root, endParts[0], filter)\n\n    const range = doc.createRange()\n\n    if (start.before) range.setStartBefore(start.node)\n    else if (start.after) range.setStartAfter(start.node)\n    else range.setStart(start.node, start.offset)\n\n    if (end.before) range.setEndBefore(end.node)\n    else if (end.after) range.setEndAfter(end.node)\n    else range.setEnd(end.node, end.offset)\n    return range\n}\n\n// faster way of getting CFIs for sorted elements in a single parent\nexport const fromElements = elements => {\n    const results = []\n    const { parentNode } = elements[0]\n    const parts = nodeToParts(parentNode)\n    for (const [index, node] of indexChildNodes(parentNode).entries()) {\n        const el = elements[results.length]\n        if (node === el)\n            results.push(toString([parts.concat({ id: el.id, index })]))\n    }\n    return results\n}\n\nexport const toElement = (doc, parts) =>\n    partsToNode(doc.documentElement, collapse(parts)).node\n\n// turn indices into standard CFIs when you don't have an actual package document\nexport const fake = {\n    fromIndex: index => wrap(`/6/${(index + 1) * 2}`),\n    toIndex: parts => parts?.at(-1).index / 2 - 1,\n}\n\n// get CFI from Calibre bookmarks\n// see https://github.com/johnfactotum/foliate/issues/849\nexport const fromCalibrePos = pos => {\n    const [parts] = parse(pos)\n    const item = parts.shift()\n    parts.shift()\n    return toString([[{ index: 6 }, item], parts])\n}\nexport const fromCalibreHighlight = ({ spine_index, start_cfi, end_cfi }) => {\n    const pre = fake.fromIndex(spine_index) + '!'\n    return buildRange(pre + start_cfi.slice(2), pre + end_cfi.slice(2))\n}\n","import * as CFI from './epubcfi.js'\n\nconst NS = {\n    CONTAINER: 'urn:oasis:names:tc:opendocument:xmlns:container',\n    XHTML: 'http://www.w3.org/1999/xhtml',\n    OPF: 'http://www.idpf.org/2007/opf',\n    EPUB: 'http://www.idpf.org/2007/ops',\n    DC: 'http://purl.org/dc/elements/1.1/',\n    DCTERMS: 'http://purl.org/dc/terms/',\n    ENC: 'http://www.w3.org/2001/04/xmlenc#',\n    NCX: 'http://www.daisy.org/z3986/2005/ncx/',\n    XLINK: 'http://www.w3.org/1999/xlink',\n    SMIL: 'http://www.w3.org/ns/SMIL',\n}\n\nconst MIME = {\n    XML: 'application/xml',\n    NCX: 'application/x-dtbncx+xml',\n    XHTML: 'application/xhtml+xml',\n    HTML: 'text/html',\n    CSS: 'text/css',\n    SVG: 'image/svg+xml',\n    JS: /\\/(x-)?(javascript|ecmascript)/,\n}\n\n// convert to camel case\nconst camel = x => x.toLowerCase().replace(/[-:](.)/g, (_, g) => g.toUpperCase())\n\n// strip and collapse ASCII whitespace\n// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\nconst normalizeWhitespace = str => str ? str\n    .replace(/[\\t\\n\\f\\r ]+/g, ' ')\n    .replace(/^[\\t\\n\\f\\r ]+/, '')\n    .replace(/[\\t\\n\\f\\r ]+$/, '') : ''\n\nconst filterAttribute = (attr, value, isList) => isList\n    ? el => el.getAttribute(attr)?.split(/\\s/)?.includes(value)\n    : typeof value === 'function'\n        ? el => value(el.getAttribute(attr))\n        : el => el.getAttribute(attr) === value\n\nconst getAttributes = (...xs) => el =>\n    el ? Object.fromEntries(xs.map(x => [camel(x), el.getAttribute(x)])) : null\n\nconst getElementText = el => normalizeWhitespace(el?.textContent)\n\nconst childGetter = (doc, ns) => {\n    // ignore the namespace if it doesn't appear in document at all\n    const useNS = doc.lookupNamespaceURI(null) === ns || doc.lookupPrefix(ns)\n    const f = useNS\n        ? (el, name) => el => el.namespaceURI === ns && el.localName === name\n        : (el, name) => el => el.localName === name\n    return {\n        $: (el, name) => [...el.children].find(f(el, name)),\n        $$: (el, name) => [...el.children].filter(f(el, name)),\n        $$$: useNS\n            ? (el, name) => [...el.getElementsByTagNameNS(ns, name)]\n            : (el, name) => [...el.getElementsByTagName(name)],\n    }\n}\n\nconst resolveURL = (url, relativeTo) => {\n    try {\n        if (relativeTo.includes(':')) return new URL(url, relativeTo)\n        // the base needs to be a valid URL, so set a base URL and then remove it\n        const root = 'https://invalid.invalid/'\n        const obj = new URL(url, root + relativeTo)\n        obj.search = ''\n        return decodeURI(obj.href.replace(root, ''))\n    } catch(e) {\n        console.warn(e)\n        return url\n    }\n}\n\nconst isExternal = uri => /^(?!blob)\\w+:/i.test(uri)\n\n// like `path.relative()` in Node.js\nconst pathRelative = (from, to) => {\n    if (!from) return to\n    const as = from.replace(/\\/$/, '').split('/')\n    const bs = to.replace(/\\/$/, '').split('/')\n    const i = (as.length > bs.length ? as : bs).findIndex((_, i) => as[i] !== bs[i])\n    return i < 0 ? '' : Array(as.length - i).fill('..').concat(bs.slice(i)).join('/')\n}\n\nconst pathDirname = str => str.slice(0, str.lastIndexOf('/') + 1)\n\n// replace asynchronously and sequentially\n// same techinque as https://stackoverflow.com/a/48032528\nconst replaceSeries = async (str, regex, f) => {\n    const matches = []\n    str.replace(regex, (...args) => (matches.push(args), null))\n    const results = []\n    for (const args of matches) results.push(await f(...args))\n    return str.replace(regex, () => results.shift())\n}\n\nconst regexEscape = str => str.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n\nconst LANGS = { attrs: ['dir', 'xml:lang'] }\nconst ALTS = { name: 'alternate-script', many: true, ...LANGS, props: ['file-as'] }\nconst CONTRIB = {\n    many: true, ...LANGS,\n    props: [{ name: 'role', many: true, attrs: ['scheme'] }, 'file-as', ALTS],\n    setLegacyAttrs: (obj, el) => {\n        if (!obj.role?.length) {\n            const value = el.getAttributeNS(NS.OPF, 'role')\n            if (value) obj.role = [{ value }]\n        }\n        obj.fileAs ??= el.getAttributeNS(NS.OPF, 'file-as')\n    },\n}\nconst METADATA = [\n    {\n        name: 'title', many: true, ...LANGS,\n        props: ['title-type', 'display-seq', 'file-as', ALTS],\n    },\n    {\n        name: 'identifier', many: true,\n        props: [{ name: 'identifier-type', attrs: ['scheme'] }],\n        setLegacyAttrs: (obj, el) => {\n            if (!obj.identifierType) {\n                const value = el.getAttributeNS(NS.OPF, 'scheme')\n                if (value) obj.identifierType = { value }\n            }\n        },\n    },\n    { name: 'language', many: true },\n    { name: 'creator', ...CONTRIB },\n    { name: 'contributor', ...CONTRIB },\n    { name: 'publisher', ...LANGS, props: ['file-as', ALTS] },\n    { name: 'description', ...LANGS, props: [ALTS] },\n    { name: 'rights', ...LANGS, props: [ALTS] },\n    { name: 'date' },\n    { name: 'dcterms:modified', type: 'meta' },\n    {\n        name: 'subject', many: true, ...LANGS, props: ['term', 'authority', ALTS],\n        setLegacyAttrs: (obj, el) => {\n            obj.term ??= el.getAttributeNS(NS.OPF, 'term')\n            obj.authority ??= el.getAttributeNS(NS.OPF, 'authority')\n        },\n    },\n    { name: 'source', many: true },\n    {\n        name: 'belongs-to-collection', type: 'meta', many: true, ...LANGS,\n        props: [\n            'collection-type', 'group-position', 'dcterms:identifier', 'file-as',\n            ALTS, { name: 'belongs-to-collection', recursive: true },\n        ],\n    },\n]\n\nconst getMetadata = opf => {\n    const { $, $$ } = childGetter(opf, NS.OPF)\n    const $metadata = $(opf.documentElement, 'metadata')\n    const els = Array.from($metadata.children)\n    const getValue = (obj, el) => {\n        if (!el) return null\n        const { props = [], attrs = [] } = obj\n        const value = getElementText(el)\n        if (!props.length && !attrs.length) return value\n        const id = el.getAttribute('id')\n        const refines = id ? els.filter(filterAttribute('refines', '#' + id)) : []\n        const result = Object.fromEntries([['value', value]]\n            .concat(props.map(prop => {\n                const { many, recursive } = prop\n                const name = typeof prop === 'string' ? prop : prop.name\n                const filter = filterAttribute('property', name)\n                const subobj = recursive ? obj : prop\n                return [camel(name), many\n                    ? refines.filter(filter).map(el => getValue(subobj, el))\n                    : getValue(subobj, refines.find(filter))]\n            }))\n            .concat(attrs.map(attr => [camel(attr), el.getAttribute(attr)])))\n        obj.setLegacyAttrs?.(result, el)\n        return result\n    }\n    const arr = els.filter(filterAttribute('refines', null))\n    const metadata = Object.fromEntries(METADATA.map(obj => {\n        const { type, name, many } = obj\n        const filter = type === 'meta'\n            ? el => el.namespaceURI === NS.OPF && el.getAttribute('property') === name\n            : el => el.namespaceURI === NS.DC && el.localName === name\n        return [camel(name), many ? arr.filter(filter).map(el => getValue(obj, el))\n            : getValue(obj, arr.find(filter))]\n    }))\n\n    const $$meta = $$($metadata, 'meta')\n    const getMetasByPrefix = prefix => $$meta\n        .filter(filterAttribute('property', x => x?.startsWith(prefix)))\n        .map(el => [el.getAttribute('property').replace(prefix, ''), el])\n\n    const rendition = Object.fromEntries(getMetasByPrefix('rendition:')\n        .map(([k, el]) => [k, getElementText(el)]))\n\n    const media = { narrator: [], duration: {} }\n    for (const [k, el] of getMetasByPrefix('media:')) {\n        const v = getElementText(el)\n        if (k === 'duration') media.duration[\n            el.getAttribute('refines')?.split('#')?.[1] ?? ''] = parseClock(v)\n        else if (k === 'active-class') media.activeClass = v\n        else if (k === 'narrator') media.narrator.push(v)\n        else if (k === 'playback-active-class') media.playbackActiveClass = v\n    }\n    return { metadata, rendition, media }\n}\n\nconst parseNav = (doc, resolve = f => f) => {\n    const { $, $$, $$$ } = childGetter(doc, NS.XHTML)\n    const resolveHref = href => href ? decodeURI(resolve(href)) : null\n    const parseLI = getType => $li => {\n        const $a = $($li, 'a') ?? $($li, 'span')\n        const $ol = $($li, 'ol')\n        const href = resolveHref($a?.getAttribute('href'))\n        const label = getElementText($a) || $a?.getAttribute('title')\n        // TODO: get and concat alt/title texts in content\n        const result = { label, href, subitems: parseOL($ol) }\n        if (getType) result.type = $a?.getAttributeNS(NS.EPUB, 'type')?.split(/\\s/)\n        return result\n    }\n    const parseOL = ($ol, getType) => $ol ? $$($ol, 'li').map(parseLI(getType)) : null\n    const parseNav = ($nav, getType) => parseOL($($nav, 'ol'), getType)\n\n    const $$nav = $$$(doc, 'nav')\n    let toc = null, pageList = null, landmarks = null, others = []\n    for (const $nav of $$nav) {\n        const type = $nav.getAttributeNS(NS.EPUB, 'type')?.split(/\\s/) ?? []\n        if (type.includes('toc')) toc ??= parseNav($nav)\n        else if (type.includes('page-list')) pageList ??= parseNav($nav)\n        else if (type.includes('landmarks')) landmarks ??= parseNav($nav, true)\n        else others.push({\n            label: getElementText($nav.firstElementChild), type,\n            list: parseNav($nav),\n        })\n    }\n    return { toc, pageList, landmarks, others }\n}\n\nconst parseNCX = (doc, resolve = f => f) => {\n    const { $, $$ } = childGetter(doc, NS.NCX)\n    const resolveHref = href => href ? decodeURI(resolve(href)) : null\n    const parseItem = el => {\n        const $label = $(el, 'navLabel')\n        const $content = $(el, 'content')\n        const label = getElementText($label)\n        const href = resolveHref($content.getAttribute('src'))\n        if (el.localName === 'navPoint') {\n            const els = $$(el, 'navPoint')\n            return { label, href, subitems: els.length ? els.map(parseItem) : null }\n        }\n        return { label, href }\n    }\n    const parseList = (el, itemName) => $$(el, itemName).map(parseItem)\n    const getSingle = (container, itemName) => {\n        const $container = $(doc.documentElement, container)\n        return $container ? parseList($container, itemName) : null\n    }\n    return {\n        toc: getSingle('navMap', 'navPoint'),\n        pageList: getSingle('pageList', 'pageTarget'),\n        others: $$(doc.documentElement, 'navList').map(el => ({\n            label: getElementText($(el, 'navLabel')),\n            list: parseList(el, 'navTarget'),\n        })),\n    }\n}\n\nconst parseClock = str => {\n    if (!str) return\n    const parts = str.split(':').map(x => parseFloat(x))\n    if (parts.length === 3) {\n        const [h, m, s] = parts\n        return h * 60 * 60 + m * 60 + s\n    }\n    if (parts.length === 2) {\n        const [m, s] = parts\n        return m * 60 + s\n    }\n    const [x, unit] = str.split(/(?=[^\\d.])/)\n    const n = parseFloat(x)\n    const f = unit === 'h' ? 60 * 60\n        : unit === 'min' ? 60\n        : unit === 'ms' ? .001\n        : 1\n    return n * f\n}\n\nclass MediaOverlay extends EventTarget {\n    #entries\n    #lastMediaOverlayItem\n    #sectionIndex\n    #audioIndex\n    #itemIndex\n    #audio\n    #volume = 1\n    #rate = 1\n    constructor(book, loadXML) {\n        super()\n        this.book = book\n        this.loadXML = loadXML\n    }\n    async #loadSMIL(item) {\n        if (this.#lastMediaOverlayItem === item) return\n        const doc = await this.loadXML(item.href)\n        const resolve = href => href ? resolveURL(href, item.href) : null\n        const { $, $$$ } = childGetter(doc, NS.SMIL)\n        this.#audioIndex = -1\n        this.#itemIndex = -1\n        this.#entries = $$$(doc, 'par').reduce((arr, $par) => {\n            const text = resolve($($par, 'text')?.getAttribute('src'))\n            const $audio = $($par, 'audio')\n            if (!text || !$audio) return arr\n            const src = resolve($audio.getAttribute('src'))\n            const begin = parseClock($audio.getAttribute('clipBegin'))\n            const end = parseClock($audio.getAttribute('clipEnd'))\n            const last = arr.at(-1)\n            if (last?.src === src) last.items.push({ text, begin, end })\n            else arr.push({ src, items: [{ text, begin, end }] })\n            return arr\n        }, [])\n        this.#lastMediaOverlayItem = item\n    }\n    get #activeAudio() {\n        return this.#entries[this.#audioIndex]\n    }\n    get #activeItem() {\n        return this.#activeAudio?.items?.[this.#itemIndex]\n    }\n    #error(e) {\n        console.error(e)\n        this.dispatchEvent(new CustomEvent('error', { detail: e }))\n    }\n    #highlight() {\n        this.dispatchEvent(new CustomEvent('highlight', { detail: this.#activeItem }))\n    }\n    #unhighlight() {\n        this.dispatchEvent(new CustomEvent('unhighlight', { detail: this.#activeItem }))\n    }\n    async #play(audioIndex, itemIndex) {\n        if (this.#audio) {\n            this.#audio.pause()\n            URL.revokeObjectURL(this.#audio.src)\n            this.#audio = null\n        }\n        this.#audioIndex = audioIndex\n        this.#itemIndex = itemIndex\n        const src = this.#activeAudio?.src\n        if (!src || !this.#activeItem) return this.start(this.#sectionIndex + 1)\n\n        const url = URL.createObjectURL(await this.book.loadBlob(src))\n        const audio = new Audio(url)\n        this.#audio = audio\n        audio.addEventListener('timeupdate', () => {\n            if (audio.paused) return\n            const t = audio.currentTime\n            const { items } = this.#activeAudio\n            if (t > this.#activeItem?.end) {\n                this.#unhighlight()\n                if (this.#itemIndex === items.length - 1) {\n                    this.#play(this.#audioIndex + 1, 0).catch(e => this.#error(e))\n                    return\n                }\n            }\n            const oldIndex = this.#itemIndex\n            while (items[this.#itemIndex + 1]?.begin <= t) this.#itemIndex++\n            if (this.#itemIndex !== oldIndex) this.#highlight()\n        })\n        audio.addEventListener('error', () =>\n            this.#error(new Error(`Failed to load ${src}`)))\n        audio.addEventListener('playing', () => this.#highlight())\n        audio.addEventListener('pause', () => this.#unhighlight())\n        audio.addEventListener('ended', () => {\n            this.#unhighlight()\n            URL.revokeObjectURL(url)\n            this.#audio = null\n            this.#play(audioIndex + 1, 0).catch(e => this.#error(e))\n        })\n        audio.addEventListener('canplaythrough', () => {\n            audio.currentTime = this.#activeItem.begin ?? 0\n            audio.volume = this.#volume\n            audio.playbackRate = this.#rate\n            audio.play().catch(e => this.#error(e))\n        })\n    }\n    async start(sectionIndex, filter = () => true) {\n        this.#audio?.pause()\n        const section = this.book.sections[sectionIndex]\n        const href = section?.id\n        if (!href) return\n\n        const { mediaOverlay } = section\n        if (!mediaOverlay) return this.start(sectionIndex + 1)\n        this.#sectionIndex = sectionIndex\n        await this.#loadSMIL(mediaOverlay)\n\n        for (let i = 0; i < this.#entries.length; i++) {\n            const { items } = this.#entries[i]\n            for (let j = 0; j < items.length; j++) {\n                if (items[j].text.split('#')[0] === href && filter(items[j], j, items))\n                    return this.#play(i, j).catch(e => this.#error(e))\n            }\n        }\n    }\n    pause() {\n        this.#audio?.pause()\n    }\n    resume() {\n        this.#audio?.play().catch(e => this.#error(e))\n    }\n    prev() {\n        if (this.#itemIndex > 0) this.#play(this.#audioIndex, this.#itemIndex - 1)\n        else if (this.#audioIndex > 0) this.#play(this.#audioIndex - 1,\n            this.#entries[this.#audioIndex - 1].items.length - 1)\n        else if (this.#sectionIndex > 0)\n            this.start(this.#sectionIndex - 1, (_, i, items) => i === items.length - 1)\n    }\n    next() {\n        this.#play(this.#audioIndex, this.#itemIndex + 1)\n    }\n    setVolume(volume) {\n        this.#volume = volume\n        if (this.#audio) this.#audio.volume = volume\n    }\n    setRate(rate) {\n        this.#rate = rate\n        if (this.#audio) this.#audio.playbackRate = rate\n    }\n}\n\nconst isUUID = /([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})/\n\nconst getUUID = opf => {\n    for (const el of opf.getElementsByTagNameNS(NS.DC, 'identifier')) {\n        const [id] = getElementText(el).split(':').slice(-1)\n        if (isUUID.test(id)) return id\n    }\n    return ''\n}\n\nconst getIdentifier = opf => getElementText(\n    opf.getElementById(opf.documentElement.getAttribute('unique-identifier'))\n    ?? opf.getElementsByTagNameNS(NS.DC, 'identifier')[0])\n\n// https://www.w3.org/publishing/epub32/epub-ocf.html#sec-resource-obfuscation\nconst deobfuscate = async (key, length, blob) => {\n    const array = new Uint8Array(await blob.slice(0, length).arrayBuffer())\n    length = Math.min(length, array.length)\n    for (var i = 0; i < length; i++) array[i] = array[i] ^ key[i % key.length]\n    return new Blob([array, blob.slice(length)], { type: blob.type })\n}\n\nconst WebCryptoSHA1 = async str => {\n    const data = new TextEncoder().encode(str)\n    const buffer = await globalThis.crypto.subtle.digest('SHA-1', data)\n    return new Uint8Array(buffer)\n}\n\nconst deobfuscators = (sha1 = WebCryptoSHA1) => ({\n    'http://www.idpf.org/2008/embedding': {\n        key: opf => sha1(getIdentifier(opf)\n            // eslint-disable-next-line no-control-regex\n            .replaceAll(/[\\u0020\\u0009\\u000d\\u000a]/g, '')),\n        decode: (key, blob) => deobfuscate(key, 1040, blob),\n    },\n    'http://ns.adobe.com/pdf/enc#RC': {\n        key: opf => {\n            const uuid = getUUID(opf).replaceAll('-', '')\n            return Uint8Array.from({ length: 16 }, (_, i) =>\n                parseInt(uuid.slice(i * 2, i * 2 + 2), 16))\n        },\n        decode: (key, blob) => deobfuscate(key, 1024, blob),\n    },\n})\n\nclass Encryption {\n    #uris = new Map()\n    #decoders = new Map()\n    #algorithms\n    constructor(algorithms) {\n        this.#algorithms = algorithms\n    }\n    async init(encryption, opf) {\n        if (!encryption) return\n        const data = Array.from(\n            encryption.getElementsByTagNameNS(NS.ENC, 'EncryptedData'), el => ({\n                algorithm: el.getElementsByTagNameNS(NS.ENC, 'EncryptionMethod')[0]\n                    ?.getAttribute('Algorithm'),\n                uri: el.getElementsByTagNameNS(NS.ENC, 'CipherReference')[0]\n                    ?.getAttribute('URI'),\n            }))\n        for (const { algorithm, uri } of data) {\n            if (!this.#decoders.has(algorithm)) {\n                const algo = this.#algorithms[algorithm]\n                if (!algo) {\n                    console.warn('Unknown encryption algorithm')\n                    continue\n                }\n                const key = await algo.key(opf)\n                this.#decoders.set(algorithm, blob => algo.decode(key, blob))\n            }\n            this.#uris.set(uri, algorithm)\n        }\n    }\n    getDecoder(uri) {\n        return this.#decoders.get(this.#uris.get(uri)) ?? (x => x)\n    }\n}\n\nclass Resources {\n    constructor({ opf, resolveHref }) {\n        this.opf = opf\n        const { $, $$, $$$ } = childGetter(opf, NS.OPF)\n\n        const $manifest = $(opf.documentElement, 'manifest')\n        const $spine = $(opf.documentElement, 'spine')\n        const $$itemref = $$($spine, 'itemref')\n\n        this.manifest = $$($manifest, 'item')\n            .map(getAttributes('href', 'id', 'media-type', 'properties', 'media-overlay'))\n            .map(item => {\n                item.href = resolveHref(item.href)\n                item.properties = item.properties?.split(/\\s/)\n                return item\n            })\n        this.spine = $$itemref\n            .map(getAttributes('idref', 'id', 'linear', 'properties'))\n            .map(item => (item.properties = item.properties?.split(/\\s/), item))\n        this.pageProgressionDirection = $spine\n            .getAttribute('page-progression-direction')\n\n        this.navPath = this.getItemByProperty('nav')?.href\n        this.ncxPath = (this.getItemByID($spine.getAttribute('toc'))\n            ?? this.manifest.find(item => item.mediaType === MIME.NCX))?.href\n\n        const $guide = $(opf.documentElement, 'guide')\n        if ($guide) this.guide = $$($guide, 'reference')\n            .map(getAttributes('type', 'title', 'href'))\n            .map(({ type, title, href }) => ({\n                label: title,\n                type: type.split(/\\s/),\n                href: resolveHref(href),\n            }))\n\n        this.cover = this.getItemByProperty('cover-image')\n            // EPUB 2 compat\n            ?? this.getItemByID($$$(opf, 'meta')\n                .find(filterAttribute('name', 'cover'))\n                ?.getAttribute('content'))\n            ?? this.getItemByHref(this.guide\n                ?.find(ref => ref.type.includes('cover'))?.href)\n\n        this.cfis = CFI.fromElements($$itemref)\n    }\n    getItemByID(id) {\n        return this.manifest.find(item => item.id === id)\n    }\n    getItemByHref(href) {\n        return this.manifest.find(item => item.href === href)\n    }\n    getItemByProperty(prop) {\n        return this.manifest.find(item => item.properties?.includes(prop))\n    }\n    resolveCFI(cfi) {\n        const parts = CFI.parse(cfi)\n        const top = (parts.parent ?? parts).shift()\n        let $itemref = CFI.toElement(this.opf, top)\n        // make sure it's an idref; if not, try again without the ID assertion\n        // mainly because Epub.js used to generate wrong ID assertions\n        // https://github.com/futurepress/epub.js/issues/1236\n        if ($itemref && $itemref.nodeName !== 'idref') {\n            top.at(-1).id = null\n            $itemref = CFI.toElement(this.opf, top)\n        }\n        const idref = $itemref?.getAttribute('idref')\n        const index = this.spine.findIndex(item => item.idref === idref)\n        const anchor = doc => CFI.toRange(doc, parts)\n        return { index, anchor }\n    }\n}\n\nclass Loader {\n    #cache = new Map()\n    #children = new Map()\n    #refCount = new Map()\n    allowScript = false\n    constructor({ loadText, loadBlob, resources }) {\n        this.loadText = loadText\n        this.loadBlob = loadBlob\n        this.manifest = resources.manifest\n        this.assets = resources.manifest\n        // needed only when replacing in (X)HTML w/o parsing (see below)\n        //.filter(({ mediaType }) => ![MIME.XHTML, MIME.HTML].includes(mediaType))\n    }\n    createURL(href, data, type, parent) {\n        if (!data) return ''\n        const url = URL.createObjectURL(new Blob([data], { type }))\n        this.#cache.set(href, url)\n        this.#refCount.set(href, 1)\n        if (parent) {\n            const childList = this.#children.get(parent)\n            if (childList) childList.push(href)\n            else this.#children.set(parent, [href])\n        }\n        return url\n    }\n    ref(href, parent) {\n        const childList = this.#children.get(parent)\n        if (!childList?.includes(href)) {\n            this.#refCount.set(href, this.#refCount.get(href) + 1)\n            //console.log(`referencing ${href}, now ${this.#refCount.get(href)}`)\n            if (childList) childList.push(href)\n            else this.#children.set(parent, [href])\n        }\n        return this.#cache.get(href)\n    }\n    unref(href) {\n        if (!this.#refCount.has(href)) return\n        const count = this.#refCount.get(href) - 1\n        //console.log(`unreferencing ${href}, now ${count}`)\n        if (count < 1) {\n            //console.log(`unloading ${href}`)\n            URL.revokeObjectURL(this.#cache.get(href))\n            this.#cache.delete(href)\n            this.#refCount.delete(href)\n            // unref children\n            const childList = this.#children.get(href)\n            if (childList) while (childList.length) this.unref(childList.pop())\n            this.#children.delete(href)\n        } else this.#refCount.set(href, count)\n    }\n    // load manifest item, recursively loading all resources as needed\n    async loadItem(item, parents = []) {\n        if (!item) return null\n        const { href, mediaType } = item\n\n        const isScript = MIME.JS.test(item.mediaType)\n        if (isScript && !this.allowScript) return null\n\n        const parent = parents.at(-1)\n        if (this.#cache.has(href)) return this.ref(href, parent)\n\n        const shouldReplace =\n            (isScript || [MIME.XHTML, MIME.HTML, MIME.CSS, MIME.SVG].includes(mediaType))\n            // prevent circular references\n            && parents.every(p => p !== href)\n        if (shouldReplace) return this.loadReplaced(item, parents)\n        return this.createURL(href, await this.loadBlob(href), mediaType, parent)\n    }\n    async loadHref(href, base, parents = []) {\n        if (isExternal(href)) return href\n        const path = resolveURL(href, base)\n        const item = this.manifest.find(item => item.href === path)\n        if (!item) return href\n        return this.loadItem(item, parents.concat(base))\n    }\n    async loadReplaced(item, parents = []) {\n        const { href, mediaType } = item\n        const parent = parents.at(-1)\n        const str = await this.loadText(href)\n        if (!str) return null\n\n        // note that one can also just use `replaceString` for everything:\n        // ```\n        // const replaced = await this.replaceString(str, href, parents)\n        // return this.createURL(href, replaced, mediaType, parent)\n        // ```\n        // which is basically what Epub.js does, which is simpler, but will\n        // break things like iframes (because you don't want to replace links)\n        // or text that just happen to be paths\n\n        // parse and replace in HTML\n        if ([MIME.XHTML, MIME.HTML, MIME.SVG].includes(mediaType)) {\n            let doc = new DOMParser().parseFromString(str, mediaType)\n            // change to HTML if it's not valid XHTML\n            if (mediaType === MIME.XHTML && doc.querySelector('parsererror')) {\n                console.warn(doc.querySelector('parsererror').innerText)\n                item.mediaType = MIME.HTML\n                doc = new DOMParser().parseFromString(str, item.mediaType)\n            }\n            // replace hrefs in XML processing instructions\n            // this is mainly for SVGs that use xml-stylesheet\n            if ([MIME.XHTML, MIME.SVG].includes(item.mediaType)) {\n                let child = doc.firstChild\n                while (child instanceof ProcessingInstruction) {\n                    if (child.data) {\n                        const replacedData = await replaceSeries(child.data,\n                            /(?:^|\\s*)(href\\s*=\\s*['\"])([^'\"]*)(['\"])/i,\n                            (_, p1, p2, p3) => this.loadHref(p2, href, parents)\n                                .then(p2 => `${p1}${p2}${p3}`))\n                        child.replaceWith(doc.createProcessingInstruction(\n                            child.target, replacedData))\n                    }\n                    child = child.nextSibling\n                }\n            }\n            // replace hrefs (excluding anchors)\n            // TODO: srcset?\n            const replace = async (el, attr) => el.setAttribute(attr,\n                await this.loadHref(el.getAttribute(attr), href, parents))\n            for (const el of doc.querySelectorAll('link[href]')) await replace(el, 'href')\n            for (const el of doc.querySelectorAll('[src]')) await replace(el, 'src')\n            for (const el of doc.querySelectorAll('[poster]')) await replace(el, 'poster')\n            for (const el of doc.querySelectorAll('object[data]')) await replace(el, 'data')\n            for (const el of doc.querySelectorAll('[*|href]:not([href]'))\n                el.setAttributeNS(NS.XLINK, 'href', await this.loadHref(\n                    el.getAttributeNS(NS.XLINK, 'href'), href, parents))\n            // replace inline styles\n            for (const el of doc.querySelectorAll('style'))\n                if (el.textContent) el.textContent =\n                    await this.replaceCSS(el.textContent, href, parents)\n            for (const el of doc.querySelectorAll('[style]'))\n                el.setAttribute('style',\n                    await this.replaceCSS(el.getAttribute('style'), href, parents))\n            // TODO: replace inline scripts? probably not worth the trouble\n            const result = new XMLSerializer().serializeToString(doc)\n            return this.createURL(href, result, item.mediaType, parent)\n        }\n\n        const result = mediaType === MIME.CSS\n            ? await this.replaceCSS(str, href, parents)\n            : await this.replaceString(str, href, parents)\n        return this.createURL(href, result, mediaType, parent)\n    }\n    async replaceCSS(str, href, parents = []) {\n        const replacedUrls = await replaceSeries(str,\n            /url\\(\\s*[\"']?([^'\"\\n]*?)\\s*[\"']?\\s*\\)/gi,\n            (_, url) => this.loadHref(url, href, parents)\n                .then(url => `url(\"${url}\")`))\n        // apart from `url()`, strings can be used for `@import` (but why?!)\n        const replacedImports = await replaceSeries(replacedUrls,\n            /@import\\s*[\"']([^\"'\\n]*?)[\"']/gi,\n            (_, url) => this.loadHref(url, href, parents)\n                .then(url => `@import \"${url}\"`))\n        const w = window?.innerWidth ?? 800\n        const h = window?.innerHeight ?? 600\n        return replacedImports\n            // unprefix as most of the props are (only) supported unprefixed\n            .replace(/(?<=[{\\s;])-epub-/gi, '')\n            // replace vw and vh as they cause problems with layout\n            .replace(/(\\d*\\.?\\d+)vw/gi, (_, d) => parseFloat(d) * w / 100 + 'px')\n            .replace(/(\\d*\\.?\\d+)vh/gi, (_, d) => parseFloat(d) * h / 100 + 'px')\n            // `page-break-*` unsupported in columns; replace with `column-break-*`\n            .replace(/page-break-(after|before|inside)\\s*:/gi, (_, x) =>\n                `-webkit-column-break-${x}:`)\n            .replace(/break-(after|before|inside)\\s*:\\s*(avoid-)?page/gi, (_, x, y) =>\n                `break-${x}: ${y ?? ''}column`)\n    }\n    // find & replace all possible relative paths for all assets without parsing\n    replaceString(str, href, parents = []) {\n        const assetMap = new Map()\n        const urls = this.assets.map(asset => {\n            // do not replace references to the file itself\n            if (asset.href === href) return\n            // href was decoded and resolved when parsing the manifest\n            const relative = pathRelative(pathDirname(href), asset.href)\n            const relativeEnc = encodeURI(relative)\n            const rootRelative = '/' + asset.href\n            const rootRelativeEnc = encodeURI(rootRelative)\n            const set = new Set([relative, relativeEnc, rootRelative, rootRelativeEnc])\n            for (const url of set) assetMap.set(url, asset)\n            return Array.from(set)\n        }).flat().filter(x => x)\n        if (!urls.length) return str\n        const regex = new RegExp(urls.map(regexEscape).join('|'), 'g')\n        return replaceSeries(str, regex, async match =>\n            this.loadItem(assetMap.get(match.replace(/^\\//, '')),\n                parents.concat(href)))\n    }\n    unloadItem(item) {\n        this.unref(item?.href)\n    }\n    destroy() {\n        for (const url of this.#cache.values()) URL.revokeObjectURL(url)\n    }\n}\n\nconst getHTMLFragment = (doc, id) => doc.getElementById(id)\n    ?? doc.querySelector(`[name=\"${CSS.escape(id)}\"]`)\n\nconst getPageSpread = properties => {\n    for (const p of properties) {\n        if (p === 'page-spread-left' || p === 'rendition:page-spread-left')\n            return 'left'\n        if (p === 'page-spread-right' || p === 'rendition:page-spread-right')\n            return 'right'\n        if (p === 'rendition:page-spread-center') return 'center'\n    }\n}\n\nexport class EPUB {\n    parser = new DOMParser()\n    #loader\n    #encryption\n    constructor({ loadText, loadBlob, getSize, sha1 }) {\n        this.loadText = loadText\n        this.loadBlob = loadBlob\n        this.getSize = getSize\n        this.#encryption = new Encryption(deobfuscators(sha1))\n    }\n    async #loadXML(uri) {\n        const str = await this.loadText(uri)\n        if (!str) return null\n        const doc = this.parser.parseFromString(str, MIME.XML)\n        if (doc.querySelector('parsererror'))\n            throw new Error(`XML parsing error: ${uri}\n${doc.querySelector('parsererror').innerText}`)\n        return doc\n    }\n    async init() {\n        const $container = await this.#loadXML('META-INF/container.xml')\n        if (!$container) throw new Error('Failed to load container file')\n\n        const opfs = Array.from(\n            $container.getElementsByTagNameNS(NS.CONTAINER, 'rootfile'),\n            getAttributes('full-path', 'media-type'))\n            .filter(file => file.mediaType === 'application/oebps-package+xml')\n\n        if (!opfs.length) throw new Error('No package document defined in container')\n        const opfPath = opfs[0].fullPath\n        const opf = await this.#loadXML(opfPath)\n        if (!opf) throw new Error('Failed to load package document')\n\n        const $encryption = await this.#loadXML('META-INF/encryption.xml')\n        await this.#encryption.init($encryption, opf)\n\n        this.resources = new Resources({\n            opf,\n            resolveHref: url => resolveURL(url, opfPath),\n        })\n        this.#loader = new Loader({\n            loadText: this.loadText,\n            loadBlob: uri => Promise.resolve(this.loadBlob(uri))\n                .then(this.#encryption.getDecoder(uri)),\n            resources: this.resources,\n        })\n        this.sections = this.resources.spine.map((spineItem, index) => {\n            const { idref, linear, properties = [] } = spineItem\n            const item = this.resources.getItemByID(idref)\n            if (!item) {\n                console.warn(`Could not find item with ID \"${idref}\" in manifest`)\n                return null\n            }\n            return {\n                id: item.href,\n                load: () => this.#loader.loadItem(item),\n                unload: () => this.#loader.unloadItem(item),\n                createDocument: () => this.loadDocument(item),\n                size: this.getSize(item.href),\n                cfi: this.resources.cfis[index],\n                linear,\n                pageSpread: getPageSpread(properties),\n                resolveHref: href => resolveURL(href, item.href),\n                mediaOverlay: item.mediaOverlay\n                    ? this.resources.getItemByID(item.mediaOverlay) : null,\n            }\n        }).filter(s => s)\n\n        const { navPath, ncxPath } = this.resources\n        if (navPath) try {\n            const resolve = url => resolveURL(url, navPath)\n            const nav = parseNav(await this.#loadXML(navPath), resolve)\n            this.toc = nav.toc\n            this.pageList = nav.pageList\n            this.landmarks = nav.landmarks\n        } catch(e) {\n            console.warn(e)\n        }\n        if (!this.toc && ncxPath) try {\n            const resolve = url => resolveURL(url, ncxPath)\n            const ncx = parseNCX(await this.#loadXML(ncxPath), resolve)\n            this.toc = ncx.toc\n            this.pageList = ncx.pageList\n        } catch(e) {\n            console.warn(e)\n        }\n        this.landmarks ??= this.resources.guide\n\n        const { metadata, rendition, media } = getMetadata(opf)\n        this.rendition = rendition\n        this.media = media\n        this.dir = this.resources.pageProgressionDirection\n\n        this.parsedMetadata = metadata // for debugging or advanced use cases\n        const title = metadata?.title?.[0]\n        this.metadata = {\n            title: title?.value,\n            subtitle: metadata?.title?.find(x => x.titleType === 'subtitle')?.value,\n            sortAs: title?.fileAs,\n            language: metadata?.language,\n            identifier: getIdentifier(opf),\n            description: metadata?.description?.value,\n            publisher: metadata?.publisher?.value,\n            published: metadata?.date,\n            modified: metadata?.dctermsModified,\n            subject: metadata?.subject\n                ?.filter(({ value, term }) => value || term)\n                ?.map(({ value, term, authority }) =>\n                    ({ name: value, code: term, scheme: authority })),\n            rights: metadata?.rights?.value,\n        }\n        const relators = {\n            art: 'artist',\n            aut: 'author',\n            bkp: 'producer',\n            clr: 'colorist',\n            edt: 'editor',\n            ill: 'illustrator',\n            nrt: 'narrator',\n            trl: 'translator',\n            pbl: 'publisher',\n        }\n        const mapContributor = defaultKey => obj => {\n            const keys = [...new Set(obj.role?.map(({ value, scheme }) =>\n                (!scheme || scheme === 'marc:relators' ? relators[value] : null)\n                ?? defaultKey))]\n            const value = { name: obj.value, sortAs: obj.fileAs }\n            return [keys?.length ? keys : [defaultKey], value]\n        }\n        metadata?.creator?.map(mapContributor('author'))\n            ?.concat(metadata?.contributor?.map?.(mapContributor('contributor')))\n            ?.forEach(([keys, value]) => keys.forEach(key => {\n                if (this.metadata[key]) this.metadata[key].push(value)\n                else this.metadata[key] = [value]\n            }))\n\n        return this\n    }\n    async loadDocument(item) {\n        const str = await this.loadText(item.href)\n        return this.parser.parseFromString(str, item.mediaType)\n    }\n    getMediaOverlay() {\n        return new MediaOverlay(this, this.#loadXML.bind(this))\n    }\n    resolveCFI(cfi) {\n        return this.resources.resolveCFI(cfi)\n    }\n    resolveHref(href) {\n        const [path, hash] = href.split('#')\n        const item = this.resources.getItemByHref(decodeURI(path))\n        if (!item) return null\n        const index = this.resources.spine.findIndex(({ idref }) => idref === item.id)\n        const anchor = hash ? doc => getHTMLFragment(doc, hash) : () => 0\n        return { index, anchor }\n    }\n    splitTOCHref(href) {\n        return href?.split('#') ?? []\n    }\n    getTOCFragment(doc, id) {\n        return doc.getElementById(id)\n            ?? doc.querySelector(`[name=\"${CSS.escape(id)}\"]`)\n    }\n    isExternal(uri) {\n        return isExternal(uri)\n    }\n    async getCover() {\n        const cover = this.resources?.cover\n        return cover?.href\n            ? new Blob([await this.loadBlob(cover.href)], { type: cover.mediaType })\n            : null\n    }\n    async getCalibreBookmarks() {\n        const txt = await this.loadText('META-INF/calibre_bookmarks.txt')\n        const magic = 'encoding=json+base64:'\n        if (txt?.startsWith(magic)) {\n            const json = atob(txt.slice(magic.length))\n            return JSON.parse(json)\n        }\n    }\n    destroy() {\n        this.#loader?.destroy()\n    }\n}\n"],"names":["_classPrivateFieldBase","e","t","hasOwnProperty","call","TypeError","id","_classPrivateFieldKey","splitAt","arr","is","length","reduce","_ref","b","_xs$concat","xs","a","concat","slice","isNumber","isCFI","escapeCFI","str","replace","wrap","x","test","f","_len2","arguments","Array","_key2","join","findTokens","tokens","findIndices","map","i","filter","_ref2","parser","parts","state","type","val","push","index","_last$spatial","last","offset","temporal","spatial","side","_last$text","text","parserIndir","parse","cfi","escape","value","cat","char","from","trim","_state","parseInt","parseFloat","startsWith","tokenizer","_x$match$","_x$match","match","unwrap","commas","parent","start","end","partToString","_ref3","_text$map$join","_text$map","param","toInnerString","parsed","toString","collapse","toEnd","concatArrays","isTextNode","_ref4","nodeType","isElementNode","_ref5","getChildNodes","node","nodes","childNodes","accept","NodeFilter","FILTER_REJECT","FILTER_SKIP","flat","indexChildNodes","isArray","unshift","partsToNode","el","ownerDocument","getElementById","_node$firstChild","_node$lastChild","newNode","firstChild","lastChild","before","after","sum","n","nodeValue","nodeToParts","parentNode","indexed","findIndex","some","chunk","part","documentElement","toElement","doc","NS","MIME","XML","NCX","XHTML","HTML","CSS","SVG","JS","camel","toLowerCase","_","g","toUpperCase","filterAttribute","attr","isList","_el$getAttribute","_el$getAttribute$spli","getAttribute","split","includes","getAttributes","_len","_key","Object","fromEntries","getElementText","normalizeWhitespace","textContent","childGetter","ns","useNS","lookupNamespaceURI","lookupPrefix","name","namespaceURI","localName","$","children","find","$$","$$$","getElementsByTagNameNS","getElementsByTagName","resolveURL","url","relativeTo","URL","root","obj","search","decodeURI","href","console","warn","isExternal","uri","replaceSeries","async","regex","matches","args","results","shift","regexEscape","LANGS","attrs","ALTS","many","props","CONTRIB","setLegacyAttrs","_obj$role","_obj$fileAs","role","getAttributeNS","fileAs","METADATA","identifierType","_obj$term","_obj$authority","term","authority","recursive","parseNav","resolve","undefined","parseLI","getType","$li","_$","_$a$getAttributeNS","$a","$ol","resolveHref","result","label","subitems","parseOL","$nav","$$nav","toc","pageList","landmarks","others","_$nav$getAttributeNS$","_$nav$getAttributeNS","_toc","_pageList","_landmarks","firstElementChild","list","parseNCX","parseItem","$label","$content","els","parseList","itemName","getSingle","container","$container","parseClock","h","m","s","unit","_entries","_classPrivateFieldLooseKey","_lastMediaOverlayItem","_sectionIndex","_audioIndex","_itemIndex","_audio","_volume","_rate","_loadSMIL","_activeAudio","_activeItem","_error","_highlight","_unhighlight","_play","MediaOverlay","EventTarget","constructor","book","loadXML","super","defineProperty","_play2","_unhighlight2","_highlight2","_error2","get","_get_activeItem","set","_get_activeAudio","_loadSMIL2","writable","this","sectionIndex","_classPrivateFieldLoo","_classPrivateFieldLooseBase","pause","section","sections","mediaOverlay","items","j","catch","_classPrivateFieldLoo2","resume","_classPrivateFieldLoo3","play","prev","next","setVolume","volume","setRate","rate","playbackRate","item","$par","_$2","$audio","src","begin","at","_classPrivateFieldLoo6","_classPrivateFieldLoo7","error","dispatchEvent","CustomEvent","detail","audioIndex","itemIndex","_classPrivateFieldLoo8","revokeObjectURL","createObjectURL","loadBlob","audio","Audio","addEventListener","_classPrivateFieldLoo9","paused","currentTime","oldIndex","_items","Error","_classPrivateFieldLoo10","isUUID","getIdentifier","opf","_opf$getElementById","deobfuscate","key","blob","array","Uint8Array","arrayBuffer","Math","min","Blob","WebCryptoSHA1","data","TextEncoder","encode","buffer","globalThis","crypto","subtle","digest","deobfuscators","sha1","replaceAll","decode","uuid","getUUID","_uris","_decoders","_algorithms","Encryption","algorithms","Map","init","encryption","_el$getElementsByTagN","_el$getElementsByTagN2","algorithm","has","algo","getDecoder","_classPrivateFieldLoo4","Resources","_this$getItemByProper","_this$getItemByID","_this$getItemByProper2","_$$$$find","_this$guide","_this$guide$find","$manifest","$spine","$$itemref","manifest","_item$properties","properties","spine","_item$properties2","pageProgressionDirection","navPath","getItemByProperty","ncxPath","getItemByID","mediaType","$guide","guide","title","cover","getItemByHref","ref","cfis","elements","entries","CFI","prop","_item$properties3","resolveCFI","_parts$parent","_$itemref","top","$itemref","nodeName","idref","anchor","toRange","startParts","endParts","range","createRange","setStartBefore","setStartAfter","setStart","setEndBefore","setEndAfter","setEnd","_cache","_children","_refCount","Loader","_ref6","loadText","resources","allowScript","assets","createURL","childList","unref","count","delete","pop","loadItem","parents","isScript","every","p","loadReplaced","loadHref","base","path","DOMParser","parseFromString","querySelector","innerText","child","ProcessingInstruction","replacedData","p1","p2","p3","then","replaceWith","createProcessingInstruction","target","nextSibling","setAttribute","querySelectorAll","setAttributeNS","replaceCSS","XMLSerializer","serializeToString","replaceString","_window$innerWidth","_window","_window$innerHeight","_window2","replacedUrls","replacedImports","w","window","innerWidth","innerHeight","d","y","assetMap","urls","asset","relative","pathRelative","to","as","bs","fill","lastIndexOf","pathDirname","relativeEnc","encodeURI","rootRelative","rootRelativeEnc","Set","RegExp","unloadItem","destroy","values","getPageSpread","_loader","_encryption","_loadXML","EPUB","_ref7","getSize","_loadXML2","_this$landmarks","_metadata$title","_metadata$title2","_metadata$title2$find","_metadata$description","_metadata$publisher","_metadata$subject","_metadata$subject$fil","_metadata$rights","_metadata$creator","_metadata$creator$map","_metadata$creator$map2","_metadata$contributor","_metadata$contributor2","opfs","file","opfPath","fullPath","$encryption","Promise","spineItem","linear","load","unload","createDocument","loadDocument","size","pageSpread","nav","ncx","metadata","rendition","media","$metadata","getValue","_obj$setLegacyAttrs","refines","subobj","$$meta","getMetasByPrefix","prefix","k","narrator","duration","_el$getAttribute$spli2","_el$getAttribute2","_el$getAttribute2$spl","v","activeClass","playbackActiveClass","getMetadata","dir","parsedMetadata","subtitle","titleType","sortAs","language","identifier","description","publisher","published","date","modified","dctermsModified","subject","_ref8","_ref9","code","scheme","rights","relators","art","aut","bkp","clr","edt","ill","nrt","trl","pbl","mapContributor","defaultKey","_obj$role2","keys","_ref10","_ref11","creator","contributor","forEach","_ref12","getMediaOverlay","bind","hash","_ref13","getHTMLFragment","_doc$getElementById","splitTOCHref","_href$split","getTOCFragment","_doc$getElementById2","getCover","_this$resources","getCalibreBookmarks","txt","magic","json","atob","JSON","_classPrivateFieldLoo5"],"sourceRoot":""}