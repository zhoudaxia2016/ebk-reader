{"version":3,"file":"static/js/730.711e42db.chunk.js","mappings":"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","sources":["foliate-js/mobi.js"],"sourcesContent":["const unescapeHTML = str => {\n    if (!str) return ''\n    const textarea = document.createElement('textarea')\n    textarea.innerHTML = str\n    return textarea.value\n}\n\nconst MIME = {\n    XML: 'application/xml',\n    XHTML: 'application/xhtml+xml',\n    HTML: 'text/html',\n    CSS: 'text/css',\n    SVG: 'image/svg+xml',\n}\n\nconst PDB_HEADER = {\n    name: [0, 32, 'string'],\n    type: [60, 4, 'string'],\n    creator: [64, 4, 'string'],\n    numRecords: [76, 2, 'uint'],\n}\n\nconst PALMDOC_HEADER = {\n    compression: [0, 2, 'uint'],\n    numTextRecords: [8, 2, 'uint'],\n    recordSize: [10, 2, 'uint'],\n    encryption: [12, 2, 'uint'],\n}\n\nconst MOBI_HEADER = {\n    magic: [16, 4, 'string'],\n    length: [20, 4, 'uint'],\n    type: [24, 4, 'uint'],\n    encoding: [28, 4, 'uint'],\n    uid: [32, 4, 'uint'],\n    version: [36, 4, 'uint'],\n    titleOffset: [84, 4, 'uint'],\n    titleLength: [88, 4, 'uint'],\n    localeRegion: [94, 1, 'uint'],\n    localeLanguage: [95, 1, 'uint'],\n    resourceStart: [108, 4, 'uint'],\n    huffcdic: [112, 4, 'uint'],\n    numHuffcdic: [116, 4, 'uint'],\n    exthFlag: [128, 4, 'uint'],\n    trailingFlags: [240, 4, 'uint'],\n    indx: [244, 4, 'uint'],\n}\n\nconst KF8_HEADER = {\n    resourceStart: [108, 4, 'uint'],\n    fdst: [192, 4, 'uint'],\n    numFdst: [196, 4, 'uint'],\n    frag: [248, 4, 'uint'],\n    skel: [252, 4, 'uint'],\n    guide: [260, 4, 'uint'],\n}\n\nconst EXTH_HEADER = {\n    magic: [0, 4, 'string'],\n    length: [4, 4, 'uint'],\n    count: [8, 4, 'uint'],\n}\n\nconst INDX_HEADER = {\n    magic: [0, 4, 'string'],\n    length: [4, 4, 'uint'],\n    type: [8, 4, 'uint'],\n    idxt: [20, 4, 'uint'],\n    numRecords: [24, 4, 'uint'],\n    encoding: [28, 4, 'uint'],\n    language: [32, 4, 'uint'],\n    total: [36, 4, 'uint'],\n    ordt: [40, 4, 'uint'],\n    ligt: [44, 4, 'uint'],\n    numLigt: [48, 4, 'uint'],\n    numCncx: [52, 4, 'uint'],\n}\n\nconst TAGX_HEADER = {\n    magic: [0, 4, 'string'],\n    length: [4, 4, 'uint'],\n    numControlBytes: [8, 4, 'uint'],\n}\n\nconst HUFF_HEADER = {\n    magic: [0, 4, 'string'],\n    offset1: [8, 4, 'uint'],\n    offset2: [12, 4, 'uint'],\n}\n\nconst CDIC_HEADER = {\n    magic: [0, 4, 'string'],\n    length: [4, 4, 'uint'],\n    numEntries: [8, 4, 'uint'],\n    codeLength: [12, 4, 'uint'],\n}\n\nconst FDST_HEADER = {\n    magic: [0, 4, 'string'],\n    numEntries: [8, 4, 'uint'],\n}\n\nconst FONT_HEADER = {\n    flags: [8, 4, 'uint'],\n    dataStart: [12, 4, 'uint'],\n    keyLength: [16, 4, 'uint'],\n    keyStart: [20, 4, 'uint'],\n}\n\nconst MOBI_ENCODING = {\n    1252: 'windows-1252',\n    65001: 'utf-8',\n}\n\nconst EXTH_RECORD_TYPE = {\n    100: ['creator', 'string', true],\n    101: ['publisher'],\n    103: ['description'],\n    104: ['isbn'],\n    105: ['subject', 'string', true],\n    106: ['date'],\n    108: ['contributor', 'string', true],\n    109: ['rights'],\n    110: ['subjectCode', 'string', true],\n    112: ['source', 'string', true],\n    113: ['asin'],\n    121: ['boundary', 'uint'],\n    122: ['fixedLayout'],\n    125: ['numResources', 'uint'],\n    126: ['originalResolution'],\n    127: ['zeroGutter'],\n    128: ['zeroMargin'],\n    129: ['coverURI'],\n    132: ['regionMagnification'],\n    201: ['coverOffset', 'uint'],\n    202: ['thumbnailOffset', 'uint'],\n    503: ['title'],\n    524: ['language', 'string', true],\n    527: ['pageProgressionDirection'],\n}\n\nconst MOBI_LANG = {\n    1: ['ar', 'ar-SA', 'ar-IQ', 'ar-EG', 'ar-LY', 'ar-DZ', 'ar-MA', 'ar-TN', 'ar-OM',\n        'ar-YE', 'ar-SY', 'ar-JO', 'ar-LB', 'ar-KW', 'ar-AE', 'ar-BH', 'ar-QA'],\n    2: ['bg'], 3: ['ca'], 4: ['zh', 'zh-TW', 'zh-CN', 'zh-HK', 'zh-SG'], 5: ['cs'],\n    6: ['da'], 7: ['de', 'de-DE', 'de-CH', 'de-AT', 'de-LU', 'de-LI'], 8: ['el'],\n    9: ['en', 'en-US', 'en-GB', 'en-AU', 'en-CA', 'en-NZ', 'en-IE', 'en-ZA',\n        'en-JM', null, 'en-BZ', 'en-TT', 'en-ZW', 'en-PH'],\n    10: ['es', 'es-ES', 'es-MX', null, 'es-GT', 'es-CR', 'es-PA', 'es-DO',\n        'es-VE', 'es-CO', 'es-PE', 'es-AR', 'es-EC', 'es-CL', 'es-UY', 'es-PY',\n        'es-BO', 'es-SV', 'es-HN', 'es-NI', 'es-PR'],\n    11: ['fi'], 12: ['fr', 'fr-FR', 'fr-BE', 'fr-CA', 'fr-CH', 'fr-LU', 'fr-MC'],\n    13: ['he'], 14: ['hu'], 15: ['is'], 16: ['it', 'it-IT', 'it-CH'],\n    17: ['ja'], 18: ['ko'], 19: ['nl', 'nl-NL', 'nl-BE'], 20: ['no', 'nb', 'nn'],\n    21: ['pl'], 22: ['pt', 'pt-BR', 'pt-PT'], 23: ['rm'], 24: ['ro'], 25: ['ru'],\n    26: ['hr', null, 'sr'], 27: ['sk'], 28: ['sq'], 29: ['sv', 'sv-SE', 'sv-FI'],\n    30: ['th'], 31: ['tr'], 32: ['ur'], 33: ['id'], 34: ['uk'], 35: ['be'],\n    36: ['sl'], 37: ['et'], 38: ['lv'], 39: ['lt'], 41: ['fa'], 42: ['vi'],\n    43: ['hy'], 44: ['az'], 45: ['eu'], 46: ['hsb'], 47: ['mk'], 48: ['st'],\n    49: ['ts'], 50: ['tn'], 52: ['xh'], 53: ['zu'], 54: ['af'], 55: ['ka'],\n    56: ['fo'], 57: ['hi'], 58: ['mt'], 59: ['se'], 62: ['ms'], 63: ['kk'],\n    65: ['sw'], 67: ['uz', null, 'uz-UZ'], 68: ['tt'], 69: ['bn'], 70: ['pa'],\n    71: ['gu'], 72: ['or'], 73: ['ta'], 74: ['te'], 75: ['kn'], 76: ['ml'],\n    77: ['as'], 78: ['mr'], 79: ['sa'], 82: ['cy', 'cy-GB'], 83: ['gl', 'gl-ES'],\n    87: ['kok'], 97: ['ne'], 98: ['fy'],\n}\n\nconst concatTypedArray = (a, b) => {\n    const result = new a.constructor(a.length + b.length)\n    result.set(a)\n    result.set(b, a.length)\n    return result\n}\nconst concatTypedArray3 = (a, b, c) => {\n    const result = new a.constructor(a.length + b.length + c.length)\n    result.set(a)\n    result.set(b, a.length)\n    result.set(c, a.length + b.length)\n    return result\n}\n\nconst decoder = new TextDecoder()\nconst getString = buffer => decoder.decode(buffer)\nconst getUint = buffer => {\n    if (!buffer) return\n    const l = buffer.byteLength\n    const func = l === 4 ? 'getUint32' : l === 2 ? 'getUint16' : 'getUint8'\n    return new DataView(buffer)[func](0)\n}\nconst getStruct = (def, buffer) => Object.fromEntries(Array.from(Object.entries(def))\n    .map(([key, [start, len, type]]) => [key,\n        (type === 'string' ? getString : getUint)(buffer.slice(start, start + len))]))\n\nconst getDecoder = x => new TextDecoder(MOBI_ENCODING[x])\n\nconst getVarLen = (byteArray, i = 0) => {\n    let value = 0, length = 0\n    for (const byte of byteArray.subarray(i, i + 4)) {\n        value = (value << 7) | (byte & 0b111_1111) >>> 0\n        length++\n        if (byte & 0b1000_0000) break\n    }\n    return { value, length }\n}\n\n// variable-length quantity, but read from the end of data\nconst getVarLenFromEnd = byteArray => {\n    let value = 0\n    for (const byte of byteArray.subarray(-4)) {\n        // `byte & 0b1000_0000` indicates the start of value\n        if (byte & 0b1000_0000) value = 0\n        value = (value << 7) | (byte & 0b111_1111)\n    }\n    return value\n}\n\nconst countBitsSet = x => {\n    let count = 0\n    for (; x > 0; x = x >> 1) if ((x & 1) === 1) count++\n    return count\n}\n\nconst countUnsetEnd = x => {\n    let count = 0\n    while ((x & 1) === 0) x = x >> 1, count++\n    return count\n}\n\nconst decompressPalmDOC = array => {\n    let output = []\n    for (let i = 0; i < array.length; i++) {\n        const byte = array[i]\n        if (byte === 0) output.push(0) // uncompressed literal, just copy it\n        else if (byte <= 8) // copy next 1-8 bytes\n            for (const x of array.subarray(i + 1, (i += byte) + 1))\n                output.push(x)\n        else if (byte <= 0b0111_1111) output.push(byte) // uncompressed literal\n        else if (byte <= 0b1011_1111) {\n            // 1st and 2nd bits are 10, meaning this is a length-distance pair\n            // read next byte and combine it with current byte\n            const bytes = (byte << 8) | array[i++ + 1]\n            // the 3rd to 13th bits encode distance\n            const distance = (bytes & 0b0011_1111_1111_1111) >>> 3\n            // the last 3 bits, plus 3, is the length to copy\n            const length = (bytes & 0b111) + 3\n            for (let j = 0; j < length; j++)\n                output.push(output[output.length - distance])\n        }\n        // compressed from space plus char\n        else output.push(32, byte ^ 0b1000_0000)\n    }\n    return Uint8Array.from(output)\n}\n\nconst read32Bits = (byteArray, from) => {\n    const startByte = from >> 3\n    const end = from + 32\n    const endByte = end >> 3\n    let bits = 0n\n    for (let i = startByte; i <= endByte; i++)\n        bits = bits << 8n | BigInt(byteArray[i] ?? 0)\n    return (bits >> (8n - BigInt(end & 7))) & 0xffffffffn\n}\n\nconst huffcdic = async (mobi, loadRecord) => {\n    const huffRecord = await loadRecord(mobi.huffcdic)\n    const { magic, offset1, offset2 } = getStruct(HUFF_HEADER, huffRecord)\n    if (magic !== 'HUFF') throw new Error('Invalid HUFF record')\n\n    // table1 is indexed by byte value\n    const table1 = Array.from({ length: 256 }, (_, i) => offset1 + i * 4)\n        .map(offset => getUint(huffRecord.slice(offset, offset + 4)))\n        .map(x => [x & 0b1000_0000, x & 0b1_1111, x >>> 8])\n\n    // table2 is indexed by code length\n    const table2 = [null].concat(Array.from({ length: 32 }, (_, i) => offset2 + i * 8)\n        .map(offset => [\n            getUint(huffRecord.slice(offset, offset + 4)),\n            getUint(huffRecord.slice(offset + 4, offset + 8))]))\n\n    const dictionary = []\n    for (let i = 1; i < mobi.numHuffcdic; i++) {\n        const record = await loadRecord(mobi.huffcdic + i)\n        const cdic = getStruct(CDIC_HEADER, record)\n        if (cdic.magic !== 'CDIC') throw new Error('Invalid CDIC record')\n        // `numEntries` is the total number of dictionary data across CDIC records\n        // so `n` here is the number of entries in *this* record\n        const n = Math.min(1 << cdic.codeLength, cdic.numEntries - dictionary.length)\n        const buffer = record.slice(cdic.length)\n        for (let i = 0; i < n; i++) {\n            const offset = getUint(buffer.slice(i * 2, i * 2 + 2))\n            const x = getUint(buffer.slice(offset, offset + 2))\n            const length = x & 0x7fff\n            const decompressed = x & 0x8000\n            const value = new Uint8Array(\n                buffer.slice(offset + 2, offset + 2 + length))\n            dictionary.push([value, decompressed])\n        }\n    }\n\n    const decompress = byteArray => {\n        let output = new Uint8Array()\n        const bitLength = byteArray.byteLength * 8\n        for (let i = 0; i < bitLength;) {\n            const bits = Number(read32Bits(byteArray, i))\n            let [found, codeLength, value] = table1[bits >>> 24]\n            if (!found) {\n                while (bits >>> (32 - codeLength) < table2[codeLength][0])\n                    codeLength += 1\n                value = table2[codeLength][1]\n            }\n            if ((i += codeLength) > bitLength) break\n\n            const code = value - (bits >>> (32 - codeLength))\n            let [result, decompressed] = dictionary[code]\n            if (!decompressed) {\n                // the result is itself compressed\n                result = decompress(result)\n                // cache the result for next time\n                dictionary[code] = [result, true]\n            }\n            output = concatTypedArray(output, result)\n        }\n        return output\n    }\n    return decompress\n}\n\nconst getIndexData = async (indxIndex, loadRecord) => {\n    const indxRecord = await loadRecord(indxIndex)\n    const indx = getStruct(INDX_HEADER, indxRecord)\n    if (indx.magic !== 'INDX') throw new Error('Invalid INDX record')\n    const decoder = getDecoder(indx.encoding)\n\n    const tagxBuffer = indxRecord.slice(indx.length)\n    const tagx = getStruct(TAGX_HEADER, tagxBuffer)\n    if (tagx.magic !== 'TAGX') throw new Error('Invalid TAGX section')\n    const numTags = (tagx.length - 12) / 4\n    const tagTable = Array.from({ length: numTags }, (_, i) =>\n        new Uint8Array(tagxBuffer.slice(12 + i * 4, 12 + i * 4 + 4)))\n\n    const cncx = {}\n    let cncxRecordOffset = 0\n    for (let i = 0; i < indx.numCncx; i++) {\n        const record = await loadRecord(indxIndex + indx.numRecords + i + 1)\n        const array = new Uint8Array(record)\n        for (let pos = 0; pos < array.byteLength;) {\n            const index = pos\n            const { value, length } = getVarLen(array, pos)\n            pos += length\n            const result = record.slice(pos, pos + value)\n            pos += value\n            cncx[cncxRecordOffset + index] = decoder.decode(result)\n        }\n        cncxRecordOffset += 0x10000\n    }\n\n    const table = []\n    for (let i = 0; i < indx.numRecords; i++) {\n        const record = await loadRecord(indxIndex + 1 + i)\n        const array = new Uint8Array(record)\n        const indx = getStruct(INDX_HEADER, record)\n        if (indx.magic !== 'INDX') throw new Error('Invalid INDX record')\n        for (let j = 0; j < indx.numRecords; j++) {\n            const offsetOffset = indx.idxt + 4 + 2 * j\n            const offset = getUint(record.slice(offsetOffset, offsetOffset + 2))\n\n            const length = getUint(record.slice(offset, offset + 1))\n            const name = getString(record.slice(offset + 1, offset + 1 + length))\n\n            const tags = []\n            const startPos = offset + 1 + length\n            let controlByteIndex = 0\n            let pos = startPos + tagx.numControlBytes\n            for (const [tag, numValues, mask, end] of tagTable) {\n                if (end & 1) {\n                    controlByteIndex++\n                    continue\n                }\n                const offset = startPos + controlByteIndex\n                const value = getUint(record.slice(offset, offset + 1)) & mask\n                if (value === mask) {\n                    if (countBitsSet(mask) > 1) {\n                        const { value, length } = getVarLen(array, pos)\n                        tags.push([tag, null, value, numValues])\n                        pos += length\n                    } else tags.push([tag, 1, null, numValues])\n                } else tags.push([tag, value >> countUnsetEnd(mask), null, numValues])\n            }\n\n            const tagMap = {}\n            for (const [tag, valueCount, valueBytes, numValues] of tags) {\n                const values = []\n                if (valueCount != null) {\n                    for (let i = 0; i < valueCount * numValues; i++) {\n                        const { value, length } = getVarLen(array, pos)\n                        values.push(value)\n                        pos += length\n                    }\n                } else {\n                    let count = 0\n                    while (count < valueBytes) {\n                        const { value, length } = getVarLen(array, pos)\n                        values.push(value)\n                        pos += length\n                        count += length\n                    }\n                }\n                tagMap[tag] = values\n            }\n            table.push({ name, tagMap })\n        }\n    }\n    return { table, cncx }\n}\n\nconst getNCX = async (indxIndex, loadRecord) => {\n    const { table, cncx } = await getIndexData(indxIndex, loadRecord)\n    const items = table.map(({ tagMap }, index) => ({\n        index,\n        offset: tagMap[1]?.[0],\n        size: tagMap[2]?.[0],\n        label: cncx[tagMap[3]] ?? '',\n        headingLevel: tagMap[4]?.[0],\n        pos: tagMap[6],\n        parent: tagMap[21]?.[0],\n        firstChild: tagMap[22]?.[0],\n        lastChild: tagMap[23]?.[0],\n    }))\n    const getChildren = item => {\n        if (item.firstChild == null) return item\n        item.children = items.filter(x => x.parent === item.index).map(getChildren)\n        return item\n    }\n    return items.filter(item => item.headingLevel === 0).map(getChildren)\n}\n\nconst getEXTH = (buf, encoding) => {\n    const { magic, count } = getStruct(EXTH_HEADER, buf)\n    if (magic !== 'EXTH') throw new Error('Invalid EXTH header')\n    const decoder = getDecoder(encoding)\n    const results = {}\n    let offset = 12\n    for (let i = 0; i < count; i++) {\n        const type = getUint(buf.slice(offset, offset + 4))\n        const length = getUint(buf.slice(offset + 4, offset + 8))\n        if (type in EXTH_RECORD_TYPE) {\n            const [name, typ, many] = EXTH_RECORD_TYPE[type]\n            const data = buf.slice(offset + 8, offset + length)\n            const value = typ === 'uint' ? getUint(data) : decoder.decode(data)\n            if (many) {\n                results[name] ??= []\n                results[name].push(value)\n            } else results[name] = value\n        }\n        offset += length\n    }\n    return results\n}\n\nconst getFont = async (buf, unzlib) => {\n    const { flags, dataStart, keyLength, keyStart } = getStruct(FONT_HEADER, buf)\n    const array = new Uint8Array(buf.slice(dataStart))\n    // deobfuscate font\n    if (flags & 0b10) {\n        const bytes = keyLength === 16 ? 1024 : 1040\n        const key = new Uint8Array(buf.slice(keyStart, keyStart + keyLength))\n        const length = Math.min(bytes, array.length)\n        for (var i = 0; i < length; i++) array[i] = array[i] ^ key[i % key.length]\n    }\n    // decompress font\n    if (flags & 1) try {\n        return await unzlib(array)\n    } catch (e) {\n        console.warn(e)\n        console.warn('Failed to decompress font')\n    }\n    return array\n}\n\nexport const isMOBI = async file => {\n    const magic = getString(await file.slice(60, 68).arrayBuffer())\n    return magic === 'BOOKMOBI'// || magic === 'TEXtREAd'\n}\n\nclass PDB {\n    #file\n    #offsets\n    pdb\n    async open(file) {\n        this.#file = file\n        const pdb = getStruct(PDB_HEADER, await file.slice(0, 78).arrayBuffer())\n        this.pdb = pdb\n        const buffer = await file.slice(78, 78 + pdb.numRecords * 8).arrayBuffer()\n        // get start and end offsets for each record\n        this.#offsets = Array.from({ length: pdb.numRecords },\n            (_, i) => getUint(buffer.slice(i * 8, i * 8 + 4)))\n            .map((x, i, a) => [x, a[i + 1]])\n    }\n    loadRecord(index) {\n        const offsets = this.#offsets[index]\n        if (!offsets) throw new RangeError('Record index out of bounds')\n        return this.#file.slice(...offsets).arrayBuffer()\n    }\n    async loadMagic(index) {\n        const start = this.#offsets[index][0]\n        return getString(await this.#file.slice(start, start + 4).arrayBuffer())\n    }\n}\n\nexport class MOBI extends PDB {\n    #start = 0\n    #resourceStart\n    #decoder\n    #encoder\n    #decompress\n    #removeTrailingEntries\n    constructor({ unzlib }) {\n        super()\n        this.unzlib = unzlib\n    }\n    async open(file) {\n        await super.open(file)\n        // TODO: if (this.pdb.type === 'TEXt')\n        this.headers = this.#getHeaders(await super.loadRecord(0))\n        this.#resourceStart = this.headers.mobi.resourceStart\n        let isKF8 = this.headers.mobi.version >= 8\n        if (!isKF8) {\n            const boundary = this.headers.exth?.boundary\n            if (boundary < 0xffffffff) try {\n                // it's a \"combo\" MOBI/KF8 file; try to open the KF8 part\n                this.headers = this.#getHeaders(await super.loadRecord(boundary))\n                this.#start = boundary\n                isKF8 = true\n            } catch (e) {\n                console.warn(e)\n                console.warn('Failed to open KF8; falling back to MOBI')\n            }\n        }\n        await this.#setup()\n        return isKF8 ? new KF8(this).init() : new MOBI6(this).init()\n    }\n    #getHeaders(buf) {\n        const palmdoc = getStruct(PALMDOC_HEADER, buf)\n        const mobi = getStruct(MOBI_HEADER, buf)\n        if (mobi.magic !== 'MOBI') throw new Error('Missing MOBI header')\n\n        const { titleOffset, titleLength, localeLanguage, localeRegion } = mobi\n        mobi.title = buf.slice(titleOffset, titleOffset + titleLength)\n        const lang = MOBI_LANG[localeLanguage]\n        mobi.language = lang?.[localeRegion >> 2] ?? lang?.[0]\n\n        const exth = mobi.exthFlag & 0b100_0000\n            ? getEXTH(buf.slice(mobi.length + 16), mobi.encoding) : null\n        const kf8 = mobi.version >= 8 ? getStruct(KF8_HEADER, buf) : null\n        return { palmdoc, mobi, exth, kf8 }\n    }\n    async #setup() {\n        const { palmdoc, mobi } = this.headers\n        this.#decoder = getDecoder(mobi.encoding)\n        // `TextEncoder` only supports UTF-8\n        // we are only encoding ASCII anyway, so I think it's fine\n        this.#encoder = new TextEncoder()\n\n        // set up decompressor\n        const { compression } = palmdoc\n        this.#decompress = compression === 1 ? f => f\n            : compression === 2 ? decompressPalmDOC\n            : compression === 17480 ? await huffcdic(mobi, this.loadRecord.bind(this))\n            : null\n        if (!this.#decompress) throw new Error('Unknown compression type')\n\n        // set up function for removing trailing bytes\n        const { trailingFlags } = mobi\n        const multibyte = trailingFlags & 1\n        const numTrailingEntries = countBitsSet(trailingFlags >>> 1)\n        this.#removeTrailingEntries = array => {\n            for (let i = 0; i < numTrailingEntries; i++) {\n                const length = getVarLenFromEnd(array)\n                array = array.subarray(0, -length)\n            }\n            if (multibyte) {\n                const length = (array[array.length - 1] & 0b11) + 1\n                array = array.subarray(0, -length)\n            }\n            return array\n        }\n    }\n    decode(...args) {\n        return this.#decoder.decode(...args)\n    }\n    encode(...args) {\n        return this.#encoder.encode(...args)\n    }\n    loadRecord(index) {\n        return super.loadRecord(this.#start + index)\n    }\n    loadMagic(index) {\n        return super.loadMagic(this.#start + index)\n    }\n    loadText(index) {\n        return this.loadRecord(index + 1)\n            .then(buf => new Uint8Array(buf))\n            .then(this.#removeTrailingEntries)\n            .then(this.#decompress)\n    }\n    async loadResource(index) {\n        const buf = await super.loadRecord(this.#resourceStart + index)\n        const magic = getString(buf.slice(0, 4))\n        if (magic === 'FONT') return getFont(buf, this.unzlib)\n        if (magic === 'VIDE' || magic === 'AUDI') return buf.slice(12)\n        return buf\n    }\n    getNCX() {\n        const index = this.headers.mobi.indx\n        if (index < 0xffffffff) return getNCX(index, this.loadRecord.bind(this))\n    }\n    getMetadata() {\n        const { mobi, exth } = this.headers\n        return {\n            identifier: mobi.uid.toString(),\n            title: unescapeHTML(exth?.title || this.decode(mobi.title)),\n            author: exth?.creator?.map(unescapeHTML),\n            publisher: unescapeHTML(exth?.publisher),\n            language: exth?.language ?? mobi.language,\n            published: exth?.date,\n            description: unescapeHTML(exth?.description),\n            subject: exth?.subject?.map(unescapeHTML),\n            rights: unescapeHTML(exth?.rights),\n        }\n    }\n    async getCover() {\n        const { exth } = this.headers\n        const offset = exth?.coverOffset < 0xffffffff ? exth?.coverOffset\n            : exth?.thumbnailOffset < 0xffffffff ? exth?.thumbnailOffset : null\n        if (offset != null) {\n            const buf = await this.loadResource(offset)\n            return new Blob([buf])\n        }\n    }\n}\n\nconst mbpPagebreakRegex = /<\\s*(?:mbp:)?pagebreak[^>]*>/gi\nconst fileposRegex = /<[^<>]+filepos=['\"]{0,1}(\\d+)[^<>]*>/gi\n\nconst getIndent = el => {\n    let x = 0\n    while (el) {\n        const parent = el.parentElement\n        if (parent) {\n            const tag = parent.tagName.toLowerCase()\n            if (tag === 'p') x += 1.5\n            else if (tag === 'blockquote') x += 2\n        }\n        el = parent\n    }\n    return x\n}\n\nclass MOBI6 {\n    parser = new DOMParser()\n    serializer = new XMLSerializer()\n    #resourceCache = new Map()\n    #textCache = new Map()\n    #cache = new Map()\n    #sections\n    #fileposList = []\n    #type = MIME.HTML\n    constructor(mobi) {\n        this.mobi = mobi\n    }\n    async init() {\n        // load all text records in an array\n        let array = new Uint8Array()\n        for (let i = 0; i < this.mobi.headers.palmdoc.numTextRecords; i++)\n            array = concatTypedArray(array, await this.mobi.loadText(i))\n\n        // convert to string so we can use regex\n        // note that `filepos` are byte offsets\n        // so it needs to preserve each byte as a separate character\n        // (see https://stackoverflow.com/q/50198017)\n        const str = Array.from(new Uint8Array(array),\n            c => String.fromCharCode(c)).join('')\n\n        // split content into sections at each `<mbp:pagebreak>`\n        this.#sections = [0]\n            .concat(Array.from(str.matchAll(mbpPagebreakRegex), m => m.index))\n            .map((x, i, a) => str.slice(x, a[i + 1]))\n            // recover the original raw bytes\n            .map(str => Uint8Array.from(str, x => x.charCodeAt(0)))\n            .map(raw => ({ book: this, raw }))\n            // get start and end filepos for each section\n            .reduce((arr, x) => {\n                const last = arr[arr.length - 1]\n                x.start = last?.end ?? 0\n                x.end = x.start + x.raw.byteLength\n                return arr.concat(x)\n            }, [])\n\n        this.sections = this.#sections.map((section, index) => ({\n            id: index,\n            load: () => this.loadSection(section),\n            createDocument: () => this.createDocument(section),\n            size: section.end - section.start,\n        }))\n\n        try {\n            this.landmarks = await this.getGuide()\n            const tocHref = this.landmarks\n                .find(({ type }) => type?.includes('toc'))?.href\n            if (tocHref) {\n                const { index } = this.resolveHref(tocHref)\n                const doc = await this.sections[index].createDocument()\n                let lastItem\n                let lastLevel = 0\n                let lastIndent = 0\n                const lastLevelOfIndent = new Map()\n                const lastParentOfLevel = new Map()\n                this.toc = Array.from(doc.querySelectorAll('a[filepos]'))\n                    .reduce((arr, a) => {\n                        const indent = getIndent(a)\n                        const item = {\n                            label: a.innerText?.trim(),\n                            href: `filepos:${a.getAttribute('filepos')}`,\n                        }\n                        const level = indent > lastIndent ? lastLevel + 1\n                            : indent === lastIndent ? lastLevel\n                            : lastLevelOfIndent.get(indent) ?? Math.max(0, lastLevel - 1)\n                        if (level > lastLevel) {\n                            if (lastItem) {\n                                lastItem.subitems ??= []\n                                lastItem.subitems.push(item)\n                                lastParentOfLevel.set(level, lastItem)\n                            }\n                            else arr.push(item)\n                        }\n                        else {\n                            const parent = lastParentOfLevel.get(level)\n                            if (parent) parent.subitems.push(item)\n                            else arr.push(item)\n                        }\n                        lastItem = item\n                        lastLevel = level\n                        lastIndent = indent\n                        lastLevelOfIndent.set(indent, level)\n                        return arr\n                    }, [])\n            }\n        } catch(e) {\n            console.warn(e)\n        }\n\n        // get list of all `filepos` references in the book,\n        // which will be used to insert anchor elements\n        // because only then can they be referenced in the DOM\n        this.#fileposList = [...new Set(\n            Array.from(str.matchAll(fileposRegex), m => m[1]))]\n            .map(filepos => ({ filepos, number: Number(filepos) }))\n            .sort((a, b) => a.number - b.number)\n\n        this.metadata = this.mobi.getMetadata()\n        this.getCover = this.mobi.getCover.bind(this.mobi)\n        return this\n    }\n    async getGuide() {\n        const doc = await this.createDocument(this.#sections[0])\n        return Array.from(doc.getElementsByTagName('reference'), ref => ({\n            label: ref.getAttribute('title'),\n            type: ref.getAttribute('type')?.split(/\\s/),\n            href: `filepos:${ref.getAttribute('filepos')}`,\n        }))\n    }\n    async loadResource(index) {\n        if (this.#resourceCache.has(index)) return this.#resourceCache.get(index)\n        const raw = await this.mobi.loadResource(index)\n        const url = URL.createObjectURL(new Blob([raw]))\n        this.#resourceCache.set(index, url)\n        return url\n    }\n    async loadRecindex(recindex) {\n        return this.loadResource(Number(recindex) - 1)\n    }\n    async replaceResources(doc) {\n        for (const img of doc.querySelectorAll('img[recindex]')) {\n            const recindex = img.getAttribute('recindex')\n            try {\n                img.src = await this.loadRecindex(recindex)\n            } catch {\n                console.warn(`Failed to load image ${recindex}`)\n            }\n        }\n        for (const media of doc.querySelectorAll('[mediarecindex]')) {\n            const mediarecindex = media.getAttribute('mediarecindex')\n            const recindex = media.getAttribute('recindex')\n            try {\n                media.src = await this.loadRecindex(mediarecindex)\n                if (recindex) media.poster = await this.loadRecindex(recindex)\n            } catch {\n                console.warn(`Failed to load media ${mediarecindex}`)\n            }\n        }\n        for (const a of doc.querySelectorAll('[filepos]')) {\n            const filepos = a.getAttribute('filepos')\n            a.href = `filepos:${filepos}`\n        }\n    }\n    async loadText(section) {\n        if (this.#textCache.has(section)) return this.#textCache.get(section)\n        const { raw } = section\n\n        // insert anchor elements for each `filepos`\n        const fileposList = this.#fileposList\n            .filter(({ number }) => number >= section.start && number < section.end)\n            .map(obj => ({ ...obj, offset: obj.number - section.start }))\n        let arr = raw\n        if (fileposList.length) {\n            arr = raw.subarray(0, fileposList[0].offset)\n            fileposList.forEach(({ filepos, offset }, i) => {\n                const next = fileposList[i + 1]\n                const a = this.mobi.encode(`<a id=\"filepos${filepos}\"></a>`)\n                arr = concatTypedArray3(arr, a, raw.subarray(offset, next?.offset))\n            })\n        }\n        const str = this.mobi.decode(arr).replaceAll(mbpPagebreakRegex, '')\n        this.#textCache.set(section, str)\n        return str\n    }\n    async createDocument(section) {\n        const str = await this.loadText(section)\n        return this.parser.parseFromString(str, this.#type)\n    }\n    async loadSection(section) {\n        if (this.#cache.has(section)) return this.#cache.get(section)\n        const doc = await this.createDocument(section)\n\n        // inject default stylesheet\n        const style = doc.createElement('style')\n        doc.head.append(style)\n        // blockquotes in MOBI seem to have only a small left margin by default\n        // many books seem to rely on this, as it's the only way to set margin\n        // (since there's no CSS)\n        style.append(doc.createTextNode(`blockquote {\n            margin-block-start: 0;\n            margin-block-end: 0;\n            margin-inline-start: 1em;\n            margin-inline-end: 0;\n        }`))\n\n        await this.replaceResources(doc)\n        const result = this.serializer.serializeToString(doc)\n        const url = URL.createObjectURL(new Blob([result], { type: this.#type }))\n        this.#cache.set(section, url)\n        return url\n    }\n    resolveHref(href) {\n        const filepos = href.match(/filepos:(.*)/)[1]\n        const number = Number(filepos)\n        const index = this.#sections.findIndex(section => section.end > number)\n        const anchor = doc => doc.getElementById(`filepos${filepos}`)\n        return { index, anchor }\n    }\n    splitTOCHref(href) {\n        const filepos = href.match(/filepos:(.*)/)[1]\n        const number = Number(filepos)\n        const index = this.#sections.findIndex(section => section.end > number)\n        return [index, `filepos${filepos}`]\n    }\n    getTOCFragment(doc, id) {\n        return doc.getElementById(id)\n    }\n    isExternal(uri) {\n        return /^(?!blob|filepos)\\w+:/i.test(uri)\n    }\n    destroy() {\n        for (const url of this.#resourceCache.values()) URL.revokeObjectURL(url)\n        for (const url of this.#cache.values()) URL.revokeObjectURL(url)\n    }\n}\n\n// handlers for `kindle:` uris\nconst kindleResourceRegex = /kindle:(flow|embed):(\\w+)(?:\\?mime=(\\w+\\/[-+.\\w]+))?/\nconst kindlePosRegex = /kindle:pos:fid:(\\w+):off:(\\w+)/\nconst parseResourceURI = str => {\n    const [resourceType, id, type] = str.match(kindleResourceRegex).slice(1)\n    return { resourceType, id: parseInt(id, 32), type }\n}\nconst parsePosURI = str => {\n    const [fid, off] = str.match(kindlePosRegex).slice(1)\n    return { fid: parseInt(fid, 32), off: parseInt(off, 32) }\n}\nconst makePosURI = (fid = 0, off = 0) =>\n    `kindle:pos:fid:${fid.toString(32).toUpperCase().padStart(4, '0')\n    }:off:${off.toString(32).toUpperCase().padStart(10, '0')}`\n\n// `kindle:pos:` links are originally links that contain fragments identifiers\n// so there should exist an element with `id` or `name`\n// otherwise try to find one with an `aid` attribute\nconst getFragmentSelector = str => {\n    const match = str.match(/\\s(id|name|aid)\\s*=\\s*['\"]([^'\"]*)['\"]/i)\n    if (!match) return\n    const [, attr, value] = match\n    return `[${attr}=\"${CSS.escape(value)}\"]`\n}\n\n// replace asynchronously and sequentially\nconst replaceSeries = async (str, regex, f) => {\n    const matches = []\n    str.replace(regex, (...args) => (matches.push(args), null))\n    const results = []\n    for (const args of matches) results.push(await f(...args))\n    return str.replace(regex, () => results.shift())\n}\n\nconst getPageSpread = properties => {\n    for (const p of properties) {\n        if (p === 'page-spread-left' || p === 'rendition:page-spread-left')\n            return 'left'\n        if (p === 'page-spread-right' || p === 'rendition:page-spread-right')\n            return 'right'\n        if (p === 'rendition:page-spread-center') return 'center'\n    }\n}\n\nclass KF8 {\n    parser = new DOMParser()\n    serializer = new XMLSerializer()\n    #cache = new Map()\n    #fragmentOffsets = new Map()\n    #fragmentSelectors = new Map()\n    #tables = {}\n    #sections\n    #fullRawLength\n    #rawHead = new Uint8Array()\n    #rawTail = new Uint8Array()\n    #lastLoadedHead = -1\n    #lastLoadedTail = -1\n    #type = MIME.XHTML\n    #inlineMap = new Map()\n    constructor(mobi) {\n        this.mobi = mobi\n    }\n    async init() {\n        const loadRecord = this.mobi.loadRecord.bind(this.mobi)\n        const { kf8 } = this.mobi.headers\n\n        try {\n            const fdstBuffer = await loadRecord(kf8.fdst)\n            const fdst = getStruct(FDST_HEADER, fdstBuffer)\n            if (fdst.magic !== 'FDST') throw new Error('Missing FDST record')\n            const fdstTable = Array.from({ length: fdst.numEntries },\n                (_, i) => 12 + i * 8)\n                .map(offset => [\n                    getUint(fdstBuffer.slice(offset, offset + 4)),\n                    getUint(fdstBuffer.slice(offset + 4, offset + 8))])\n            this.#tables.fdstTable = fdstTable\n            this.#fullRawLength = fdstTable[fdstTable.length - 1][1]\n        } catch {}\n\n        const skelTable = (await getIndexData(kf8.skel, loadRecord)).table\n            .map(({ name, tagMap }, index) => ({\n                index, name,\n                numFrag: tagMap[1][0],\n                offset: tagMap[6][0],\n                length: tagMap[6][1],\n            }))\n        const fragData = await getIndexData(kf8.frag, loadRecord)\n        const fragTable = fragData.table.map(({ name, tagMap }) => ({\n            insertOffset: parseInt(name),\n            selector: fragData.cncx[tagMap[2][0]],\n            index: tagMap[4][0],\n            offset: tagMap[6][0],\n            length: tagMap[6][1],\n        }))\n        this.#tables.skelTable = skelTable\n        this.#tables.fragTable = fragTable\n\n        this.#sections = skelTable.reduce((arr, skel) => {\n            const last = arr[arr.length - 1]\n            const fragStart = last?.fragEnd ?? 0, fragEnd = fragStart + skel.numFrag\n            const frags = fragTable.slice(fragStart, fragEnd)\n            const length = skel.length + frags.map(f => f.length).reduce((a, b) => a + b)\n            const totalLength = (last?.totalLength ?? 0) + length\n            return arr.concat({ skel, frags, fragEnd, length, totalLength })\n        }, [])\n\n        const resources = await this.getResourcesByMagic(['RESC', 'PAGE'])\n        const pageSpreads = new Map()\n        if (resources.RESC) {\n            const buf = await this.mobi.loadRecord(resources.RESC)\n            const str = this.mobi.decode(buf.slice(16)).replace(/\\0/g, '')\n            // the RESC record lacks the root `<package>` element\n            // but seem to be otherwise valid XML\n            const index = str.search(/\\?>/)\n            const xmlStr = `<package>${str.slice(index)}</package>`\n            const opf = this.parser.parseFromString(xmlStr, MIME.XML)\n            for (const $itemref of opf.querySelectorAll('spine > itemref')) {\n                const i = parseInt($itemref.getAttribute('skelid'))\n                pageSpreads.set(i, getPageSpread(\n                    $itemref.getAttribute('properties')?.split(' ') ?? []))\n            }\n        }\n\n        this.sections = this.#sections.map((section, index) =>\n            section.frags.length ? ({\n                id: index,\n                load: () => this.loadSection(section),\n                createDocument: () => this.createDocument(section),\n                size: section.length,\n                pageSpread: pageSpreads.get(index),\n            }) : ({ linear: 'no' }))\n\n        try {\n            const ncx = await this.mobi.getNCX()\n            const map = ({ label, pos, children }) => {\n                const [fid, off] = pos\n                const href = makePosURI(fid, off)\n                const arr = this.#fragmentOffsets.get(fid)\n                if (arr) arr.push(off)\n                else this.#fragmentOffsets.set(fid, [off])\n                return { label: unescapeHTML(label), href, subitems: children?.map(map) }\n            }\n            this.toc = ncx?.map(map)\n            this.landmarks = await this.getGuide()\n        } catch(e) {\n            console.warn(e)\n        }\n\n        const { exth } = this.mobi.headers\n        this.dir = exth.pageProgressionDirection\n        this.rendition = {\n            layout: exth.fixedLayout === 'true' ? 'pre-paginated' : 'reflowable',\n            viewport: Object.fromEntries(exth.originalResolution\n                ?.split('x')?.slice(0, 2)\n                ?.map((x, i) => [i ? 'height' : 'width', x]) ?? []),\n        }\n\n        this.metadata = this.mobi.getMetadata()\n        this.getCover = this.mobi.getCover.bind(this.mobi)\n        return this\n    }\n    // is this really the only way of getting to RESC, PAGE, etc.?\n    async getResourcesByMagic(keys) {\n        const results = {}\n        const start = this.mobi.headers.kf8.resourceStart\n        const end = this.mobi.pdb.numRecords\n        for (let i = start; i < end; i++) {\n            try {\n                const magic = await this.mobi.loadMagic(i)\n                const match = keys.find(key => key === magic)\n                if (match) results[match] = i\n            } catch {}\n        }\n        return results\n    }\n    async getGuide() {\n        const index = this.mobi.headers.kf8.guide\n        if (index < 0xffffffff) {\n            const loadRecord = this.mobi.loadRecord.bind(this.mobi)\n            const { table, cncx } = await getIndexData(index, loadRecord)\n            return table.map(({ name, tagMap }) => ({\n                label: cncx[tagMap[1][0]] ?? '',\n                type: name?.split(/\\s/),\n                href: makePosURI(tagMap[6]?.[0] ?? tagMap[3]?.[0]),\n            }))\n        }\n    }\n    async loadResourceBlob(str) {\n        const { resourceType, id, type } = parseResourceURI(str)\n        const raw = resourceType === 'flow' ? await this.loadFlow(id)\n            : await this.mobi.loadResource(id - 1)\n        const result = [MIME.XHTML, MIME.HTML, MIME.CSS, MIME.SVG].includes(type)\n            ? await this.replaceResources(this.mobi.decode(raw)) : raw\n        const doc = type === MIME.SVG ? this.parser.parseFromString(result, type) : null\n        return [new Blob([result], { type }),\n            // SVG wrappers need to be inlined\n            // as browsers don't allow external resources when loading SVG as an image\n            doc?.getElementsByTagNameNS('http://www.w3.org/2000/svg', 'image')?.length\n                ? doc.documentElement : null]\n    }\n    async loadResource(str) {\n        if (this.#cache.has(str)) return this.#cache.get(str)\n        const [blob, inline] = await this.loadResourceBlob(str)\n        const url = inline ? str : URL.createObjectURL(blob)\n        if (inline) this.#inlineMap.set(url, inline)\n        this.#cache.set(str, url)\n        return url\n    }\n    replaceResources(str) {\n        const regex = new RegExp(kindleResourceRegex, 'g')\n        return replaceSeries(str, regex, this.loadResource.bind(this))\n    }\n    // NOTE: there doesn't seem to be a way to access text randomly?\n    // how to know the decompressed size of the records without decompressing?\n    // 4096 is just the maximum size\n    async loadRaw(start, end) {\n        // here we load either from the front or back until we have reached the\n        // required offsets; at worst you'd have to load half the book at once\n        const distanceHead = end - this.#rawHead.length\n        const distanceEnd = this.#fullRawLength == null ? Infinity\n            : (this.#fullRawLength - this.#rawTail.length) - start\n        // load from the start\n        if (distanceHead < 0 || distanceHead < distanceEnd) {\n            while (this.#rawHead.length < end) {\n                const index = ++this.#lastLoadedHead\n                const data = await this.mobi.loadText(index)\n                this.#rawHead = concatTypedArray(this.#rawHead, data)\n            }\n            return this.#rawHead.slice(start, end)\n        }\n        // load from the end\n        while (this.#fullRawLength - this.#rawTail.length > start) {\n            const index = this.mobi.headers.palmdoc.numTextRecords - 1\n                - (++this.#lastLoadedTail)\n            const data = await this.mobi.loadText(index)\n            this.#rawTail = concatTypedArray(data, this.#rawTail)\n        }\n        const rawTailStart = this.#fullRawLength - this.#rawTail.length\n        return this.#rawTail.slice(start - rawTailStart, end - rawTailStart)\n    }\n    loadFlow(index) {\n        if (index < 0xffffffff)\n            return this.loadRaw(...this.#tables.fdstTable[index])\n    }\n    async loadText(section) {\n        const { skel, frags, length } = section\n        const raw = await this.loadRaw(skel.offset, skel.offset + length)\n        let skeleton = raw.slice(0, skel.length)\n        for (const frag of frags) {\n            const insertOffset = frag.insertOffset - skel.offset\n            const offset = skel.length + frag.offset\n            const fragRaw = raw.slice(offset, offset + frag.length)\n            skeleton = concatTypedArray3(\n                skeleton.slice(0, insertOffset), fragRaw,\n                skeleton.slice(insertOffset))\n\n            const offsets = this.#fragmentOffsets.get(frag.index)\n            if (offsets) for (const offset of offsets) {\n                const str = this.mobi.decode(fragRaw).slice(offset)\n                const selector = getFragmentSelector(str)\n                this.#setFragmentSelector(frag.index, offset, selector)\n            }\n        }\n        return this.mobi.decode(skeleton)\n    }\n    async createDocument(section) {\n        const str = await this.loadText(section)\n        return this.parser.parseFromString(str, this.#type)\n    }\n    async loadSection(section) {\n        if (this.#cache.has(section)) return this.#cache.get(section)\n        const str = await this.loadText(section)\n        const replaced = await this.replaceResources(str)\n\n        // by default, type is XHTML; change to HTML if it's not valid XHTML\n        let doc = this.parser.parseFromString(replaced, this.#type)\n        if (doc.querySelector('parsererror')) {\n            this.#type = MIME.HTML\n            doc = this.parser.parseFromString(replaced, this.#type)\n        }\n        for (const [url, node] of this.#inlineMap) {\n            for (const el of doc.querySelectorAll(`img[src=\"${url}\"]`))\n                el.replaceWith(node)\n        }\n        const url = URL.createObjectURL(\n            new Blob([this.serializer.serializeToString(doc)], { type: this.#type }))\n        this.#cache.set(section, url)\n        return url\n    }\n    getIndexByFID(fid) {\n        return this.#sections.findIndex(section =>\n            section.frags.some(frag => frag.index === fid))\n    }\n    #setFragmentSelector(id, offset, selector) {\n        const map = this.#fragmentSelectors.get(id)\n        if (map) map.set(offset, selector)\n        else {\n            const map = new Map()\n            this.#fragmentSelectors.set(id, map)\n            map.set(offset, selector)\n        }\n    }\n    async resolveHref(href) {\n        const { fid, off } = parsePosURI(href)\n        const index = this.getIndexByFID(fid)\n        if (index < 0) return\n\n        const saved = this.#fragmentSelectors.get(fid)?.get(off)\n        if (saved) return { index, anchor: doc => doc.querySelector(saved) }\n\n        const { skel, frags } = this.#sections[index]\n        const frag = frags.find(frag => frag.index === fid)\n        const offset = skel.offset + skel.length + frag.offset\n        const fragRaw = await this.loadRaw(offset, offset + frag.length)\n        const str = this.mobi.decode(fragRaw).slice(off)\n        const selector = getFragmentSelector(str)\n        this.#setFragmentSelector(fid, off, selector)\n        const anchor = doc => doc.querySelector(selector)\n        return { index, anchor }\n    }\n    splitTOCHref(href) {\n        const pos = parsePosURI(href)\n        const index = this.getIndexByFID(pos.fid)\n        return [index, pos]\n    }\n    getTOCFragment(doc, { fid, off }) {\n        const selector = this.#fragmentSelectors.get(fid)?.get(off)\n        return doc.querySelector(selector)\n    }\n    isExternal(uri) {\n        return /^(?!blob|kindle)\\w+:/i.test(uri)\n    }\n    destroy() {\n        for (const url of this.#cache.values()) URL.revokeObjectURL(url)\n    }\n}\n"],"names":["unescapeHTML","str","textarea","document","createElement","innerHTML","value","MIME","XML","XHTML","HTML","CSS","SVG","PDB_HEADER","name","type","creator","numRecords","PALMDOC_HEADER","compression","numTextRecords","recordSize","encryption","MOBI_HEADER","magic","length","encoding","uid","version","titleOffset","titleLength","localeRegion","localeLanguage","resourceStart","huffcdic","numHuffcdic","exthFlag","trailingFlags","indx","KF8_HEADER","fdst","numFdst","frag","skel","guide","EXTH_HEADER","count","INDX_HEADER","idxt","language","total","ordt","ligt","numLigt","numCncx","TAGX_HEADER","numControlBytes","HUFF_HEADER","offset1","offset2","CDIC_HEADER","numEntries","codeLength","FDST_HEADER","FONT_HEADER","flags","dataStart","keyLength","keyStart","MOBI_ENCODING","EXTH_RECORD_TYPE","MOBI_LANG","concatTypedArray","a","b","result","constructor","set","concatTypedArray3","c","decoder","TextDecoder","getString","buffer","decode","getUint","l","byteLength","func","DataView","getStruct","def","Object","fromEntries","Array","from","entries","map","_ref","key","start","len","slice","getDecoder","x","getVarLen","byteArray","i","arguments","undefined","byte","subarray","getVarLenFromEnd","countBitsSet","countUnsetEnd","decompressPalmDOC","array","output","push","bytes","distance","j","Uint8Array","read32Bits","end","endByte","bits","_byteArray$i","BigInt","getIndexData","async","indxIndex","loadRecord","indxRecord","Error","tagxBuffer","tagx","numTags","tagTable","_","cncx","cncxRecordOffset","record","pos","index","table","offsetOffset","offset","tags","startPos","controlByteIndex","tag","numValues","mask","tagMap","valueCount","valueBytes","values","isMOBI","file","arrayBuffer","_file","_classPrivateFieldLooseKey","_offsets","PDB","defineProperty","writable","open","_classPrivateFieldLooseBase","this","pdb","offsets","RangeError","loadMagic","_start","_resourceStart","_decoder","_encoder","_decompress","_removeTrailingEntries","_getHeaders","_setup","MOBI","_ref3","unzlib","super","_setup2","_getHeaders2","headers","mobi","isKF8","_this$headers$exth","boundary","exth","e","console","warn","KF8","init","MOBI6","encode","loadText","then","buf","loadResource","Math","min","getFont","getNCX","items","_ref2","_tagMap$","_tagMap$2","_cncx$tagMap$","_tagMap$3","_tagMap$4","_tagMap$5","_tagMap$6","size","label","headingLevel","parent","firstChild","lastChild","getChildren","item","children","filter","bind","getMetadata","_exth$creator","_exth$language","_exth$subject","identifier","toString","title","author","publisher","published","date","description","subject","rights","getCover","coverOffset","thumbnailOffset","Blob","_lang","palmdoc","lang","getEXTH","results","typ","many","data","_results$name","kf8","TextEncoder","f","huffRecord","table1","table2","concat","dictionary","cdic","n","decompressed","decompress","bitLength","Number","found","code","multibyte","numTrailingEntries","mbpPagebreakRegex","fileposRegex","_resourceCache","_textCache","_cache","_sections","_fileposList","_type","parser","DOMParser","serializer","XMLSerializer","Map","String","fromCharCode","join","matchAll","m","charCodeAt","raw","book","reduce","arr","_last$end","last","sections","section","id","load","loadSection","createDocument","_this$landmarks$find","landmarks","getGuide","tocHref","find","_ref4","includes","href","resolveHref","doc","lastItem","lastLevel","lastIndent","lastLevelOfIndent","lastParentOfLevel","toc","querySelectorAll","_a$innerText","_lastLevelOfIndent$ge","indent","el","parentElement","tagName","toLowerCase","getIndent","innerText","trim","getAttribute","level","get","max","_lastItem","_lastItem$subitems","subitems","Set","filepos","number","sort","metadata","getElementsByTagName","ref","_ref$getAttribute","split","has","url","URL","createObjectURL","loadRecindex","recindex","replaceResources","img","src","media","mediarecindex","poster","fileposList","_ref5","obj","forEach","_ref6","next","replaceAll","parseFromString","style","head","append","createTextNode","serializeToString","match","findIndex","anchor","getElementById","splitTOCHref","getTOCFragment","isExternal","uri","test","destroy","revokeObjectURL","kindleResourceRegex","kindlePosRegex","parsePosURI","fid","off","parseInt","makePosURI","toUpperCase","padStart","getFragmentSelector","attr","escape","getPageSpread","properties","p","_cache2","_fragmentOffsets","_fragmentSelectors","_tables","_sections2","_fullRawLength","_rawHead","_rawTail","_lastLoadedHead","_lastLoadedTail","_type2","_inlineMap","_setFragmentSelector","_setFragmentSelector2","_exth$originalResolut","_exth$originalResolut2","_exth$originalResolut3","_exth$originalResolut4","fdstBuffer","fdstTable","skelTable","_ref7","numFrag","fragData","fragTable","_ref8","insertOffset","selector","_last$fragEnd","_last$totalLength","fragStart","fragEnd","frags","totalLength","resources","getResourcesByMagic","pageSpreads","RESC","replace","search","xmlStr","opf","$itemref","_$itemref$getAttribut","_$itemref$getAttribut2","pageSpread","linear","ncx","_ref9","dir","pageProgressionDirection","rendition","layout","fixedLayout","viewport","originalResolution","keys","_ref10","_cncx$tagMap$1$","_tagMap$6$","_tagMap$7","_tagMap$8","loadResourceBlob","_doc$getElementsByTag","resourceType","parseResourceURI","loadFlow","getElementsByTagNameNS","documentElement","blob","inline","regex","matches","_len","args","_key","shift","replaceSeries","RegExp","loadRaw","distanceHead","distanceEnd","Infinity","rawTailStart","skeleton","fragRaw","replaced","querySelector","node","replaceWith","getIndexByFID","some","_classPrivateFieldLoo","saved","_ref11","_classPrivateFieldLoo2"],"sourceRoot":""}