{"version":3,"file":"static/js/418.2b2cd4f7.chunk.js","mappings":"mIAAO,MAAMA,EAAgBA,CAAAC,EAAiCC,KAAU,IAA1C,QAAEC,EAAO,SAAEC,EAAQ,QAAEC,GAASJ,EACxD,MAAMK,EAAQ,IAAIC,IACZC,EAAO,IAAID,IAgBXE,EAAO,CAAC,OAAQ,QAAS,OAAQ,OAAQ,OAAQ,QAAS,OAAQ,OAAQ,SAC1EC,EAAQP,EACTQ,KAAIC,GAASA,EAAMC,WACnBC,QAAOC,GAAQN,EAAKO,MAAKC,GAAOF,EAAKG,SAASD,OAC9CE,OACL,IAAKT,EAAMU,OAAQ,MAAM,IAAIC,MAAM,uCAEnC,MAAMC,EAAO,CACbA,SAAgB,IAAMlB,EAASM,EAAM,KAiBrC,OAhBAY,EAAKC,SAAW,CAAEC,MAAOtB,EAAKa,MAC9BO,EAAKG,SAAWf,EAAMC,KAAII,IAAI,CAC1BW,GAAIX,EACJY,KAAMA,IA3BGC,WACT,GAAItB,EAAMuB,IAAId,GAAO,OAAOT,EAAMwB,IAAIf,GACtC,MAAMgB,EAAMC,IAAIC,sBAAsB7B,EAASW,IACzCmB,EAAOF,IAAIC,gBACb,IAAIE,KAAK,CAAC,aAADC,OAAcL,EAAG,OAAO,CAAEM,KAAM,eAG7C,OAFA7B,EAAK8B,IAAIvB,EAAM,CAACgB,EAAKG,IACrB5B,EAAMgC,IAAIvB,EAAMmB,GACTA,CAAI,EAoBCP,CAAKZ,GACjBwB,OAAQA,IAnBGxB,KAAS,IAADyB,EAAAC,EACL,QAAdD,EAAAhC,EAAKsB,IAAIf,UAAK,IAAAyB,GAAS,QAATC,EAAdD,EAAgBE,eAAO,IAAAD,GAAvBA,EAAAE,KAAAH,GAA0BI,GAAOZ,IAAIa,gBAAgBD,KACrDpC,EAAKsC,OAAO/B,GACZT,EAAMwC,OAAO/B,EAAK,EAgBJwB,CAAOxB,GACrBgC,KAAM1C,EAAQU,OAElBO,EAAK0B,IAAMtC,EAAMC,KAAII,IAAI,CAAOkC,MAAOlC,EAAMmC,KAAMnC,MACnDO,EAAK6B,UAAY,CAAEC,OAAQ,iBAC3B9B,EAAK+B,YAAcH,IAAI,CAAOI,MAAOhC,EAAKG,SAAS8B,WAAUC,GAAKA,EAAE9B,KAAOwB,MAC3E5B,EAAKmC,aAAeP,GAAQ,CAACA,EAAM,MACnC5B,EAAKoC,eAAiBC,GAAOA,EAAIC,gBACjCtC,EAAKuC,QAAU,KACX,IAAK,MAAMC,KAAOtD,EAAKuD,SACnB,IAAK,MAAMnB,KAAOkB,EAAK9B,IAAIa,gBAAgBD,EAAI,EAEhDtB,CAAI,C","sources":["foliate-js/comic-book.js"],"sourcesContent":["export const makeComicBook = ({ entries, loadBlob, getSize }, file) => {\n    const cache = new Map()\n    const urls = new Map()\n    const load = async name => {\n        if (cache.has(name)) return cache.get(name)\n        const src = URL.createObjectURL(await loadBlob(name))\n        const page = URL.createObjectURL(\n            new Blob([`<img src=\"${src}\">`], { type: 'text/html' }))\n        urls.set(name, [src, page])\n        cache.set(name, page)\n        return page\n    }\n    const unload = name => {\n        urls.get(name)?.forEach?.(url => URL.revokeObjectURL(url))\n        urls.delete(name)\n        cache.delete(name)\n    }\n\n    const exts = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.svg', '.jxl', '.avif']\n    const files = entries\n        .map(entry => entry.filename)\n        .filter(name => exts.some(ext => name.endsWith(ext)))\n        .sort()\n    if (!files.length) throw new Error('No supported image files in archive')\n\n    const book = {}\n    book.getCover = () => loadBlob(files[0])\n    book.metadata = { title: file.name }\n    book.sections = files.map(name => ({\n        id: name,\n        load: () => load(name),\n        unload: () => unload(name),\n        size: getSize(name),\n    }))\n    book.toc = files.map(name => ({ label: name, href: name }))\n    book.rendition = { layout: 'pre-paginated' }\n    book.resolveHref = href => ({ index: book.sections.findIndex(s => s.id === href) })\n    book.splitTOCHref = href => [href, null]\n    book.getTOCFragment = doc => doc.documentElement\n    book.destroy = () => {\n        for (const arr of urls.values())\n            for (const url of arr) URL.revokeObjectURL(url)\n    }\n    return book\n}\n"],"names":["makeComicBook","_ref","file","entries","loadBlob","getSize","cache","Map","urls","exts","files","map","entry","filename","filter","name","some","ext","endsWith","sort","length","Error","book","metadata","title","sections","id","load","async","has","get","src","URL","createObjectURL","page","Blob","concat","type","set","unload","_urls$get","_urls$get$forEach","forEach","call","url","revokeObjectURL","delete","size","toc","label","href","rendition","layout","resolveHref","index","findIndex","s","splitTOCHref","getTOCFragment","doc","documentElement","destroy","arr","values"],"sourceRoot":""}