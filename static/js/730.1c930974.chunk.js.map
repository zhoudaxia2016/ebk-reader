{"version":3,"file":"static/js/730.1c930974.chunk.js","mappings":"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","sources":["../node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js","../node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js","foliate-js/mobi.js"],"sourcesContent":["function _classPrivateFieldBase(e, t) {\n  if (!{}.hasOwnProperty.call(e, t)) throw new TypeError(\"attempted to use private field on non-instance\");\n  return e;\n}\nexport { _classPrivateFieldBase as default };","var id = 0;\nfunction _classPrivateFieldKey(e) {\n  return \"__private_\" + id++ + \"_\" + e;\n}\nexport { _classPrivateFieldKey as default };","const unescapeHTML = str => {\n    if (!str) return ''\n    const textarea = document.createElement('textarea')\n    textarea.innerHTML = str\n    return textarea.value\n}\n\nconst MIME = {\n    XML: 'application/xml',\n    XHTML: 'application/xhtml+xml',\n    HTML: 'text/html',\n    CSS: 'text/css',\n    SVG: 'image/svg+xml',\n}\n\nconst PDB_HEADER = {\n    name: [0, 32, 'string'],\n    type: [60, 4, 'string'],\n    creator: [64, 4, 'string'],\n    numRecords: [76, 2, 'uint'],\n}\n\nconst PALMDOC_HEADER = {\n    compression: [0, 2, 'uint'],\n    numTextRecords: [8, 2, 'uint'],\n    recordSize: [10, 2, 'uint'],\n    encryption: [12, 2, 'uint'],\n}\n\nconst MOBI_HEADER = {\n    magic: [16, 4, 'string'],\n    length: [20, 4, 'uint'],\n    type: [24, 4, 'uint'],\n    encoding: [28, 4, 'uint'],\n    uid: [32, 4, 'uint'],\n    version: [36, 4, 'uint'],\n    titleOffset: [84, 4, 'uint'],\n    titleLength: [88, 4, 'uint'],\n    localeRegion: [94, 1, 'uint'],\n    localeLanguage: [95, 1, 'uint'],\n    resourceStart: [108, 4, 'uint'],\n    huffcdic: [112, 4, 'uint'],\n    numHuffcdic: [116, 4, 'uint'],\n    exthFlag: [128, 4, 'uint'],\n    trailingFlags: [240, 4, 'uint'],\n    indx: [244, 4, 'uint'],\n}\n\nconst KF8_HEADER = {\n    resourceStart: [108, 4, 'uint'],\n    fdst: [192, 4, 'uint'],\n    numFdst: [196, 4, 'uint'],\n    frag: [248, 4, 'uint'],\n    skel: [252, 4, 'uint'],\n    guide: [260, 4, 'uint'],\n}\n\nconst EXTH_HEADER = {\n    magic: [0, 4, 'string'],\n    length: [4, 4, 'uint'],\n    count: [8, 4, 'uint'],\n}\n\nconst INDX_HEADER = {\n    magic: [0, 4, 'string'],\n    length: [4, 4, 'uint'],\n    type: [8, 4, 'uint'],\n    idxt: [20, 4, 'uint'],\n    numRecords: [24, 4, 'uint'],\n    encoding: [28, 4, 'uint'],\n    language: [32, 4, 'uint'],\n    total: [36, 4, 'uint'],\n    ordt: [40, 4, 'uint'],\n    ligt: [44, 4, 'uint'],\n    numLigt: [48, 4, 'uint'],\n    numCncx: [52, 4, 'uint'],\n}\n\nconst TAGX_HEADER = {\n    magic: [0, 4, 'string'],\n    length: [4, 4, 'uint'],\n    numControlBytes: [8, 4, 'uint'],\n}\n\nconst HUFF_HEADER = {\n    magic: [0, 4, 'string'],\n    offset1: [8, 4, 'uint'],\n    offset2: [12, 4, 'uint'],\n}\n\nconst CDIC_HEADER = {\n    magic: [0, 4, 'string'],\n    length: [4, 4, 'uint'],\n    numEntries: [8, 4, 'uint'],\n    codeLength: [12, 4, 'uint'],\n}\n\nconst FDST_HEADER = {\n    magic: [0, 4, 'string'],\n    numEntries: [8, 4, 'uint'],\n}\n\nconst FONT_HEADER = {\n    flags: [8, 4, 'uint'],\n    dataStart: [12, 4, 'uint'],\n    keyLength: [16, 4, 'uint'],\n    keyStart: [20, 4, 'uint'],\n}\n\nconst MOBI_ENCODING = {\n    1252: 'windows-1252',\n    65001: 'utf-8',\n}\n\nconst EXTH_RECORD_TYPE = {\n    100: ['creator', 'string', true],\n    101: ['publisher'],\n    103: ['description'],\n    104: ['isbn'],\n    105: ['subject', 'string', true],\n    106: ['date'],\n    108: ['contributor', 'string', true],\n    109: ['rights'],\n    110: ['subjectCode', 'string', true],\n    112: ['source', 'string', true],\n    113: ['asin'],\n    121: ['boundary', 'uint'],\n    122: ['fixedLayout'],\n    125: ['numResources', 'uint'],\n    126: ['originalResolution'],\n    127: ['zeroGutter'],\n    128: ['zeroMargin'],\n    129: ['coverURI'],\n    132: ['regionMagnification'],\n    201: ['coverOffset', 'uint'],\n    202: ['thumbnailOffset', 'uint'],\n    503: ['title'],\n    524: ['language', 'string', true],\n    527: ['pageProgressionDirection'],\n}\n\nconst MOBI_LANG = {\n    1: ['ar', 'ar-SA', 'ar-IQ', 'ar-EG', 'ar-LY', 'ar-DZ', 'ar-MA', 'ar-TN', 'ar-OM',\n        'ar-YE', 'ar-SY', 'ar-JO', 'ar-LB', 'ar-KW', 'ar-AE', 'ar-BH', 'ar-QA'],\n    2: ['bg'], 3: ['ca'], 4: ['zh', 'zh-TW', 'zh-CN', 'zh-HK', 'zh-SG'], 5: ['cs'],\n    6: ['da'], 7: ['de', 'de-DE', 'de-CH', 'de-AT', 'de-LU', 'de-LI'], 8: ['el'],\n    9: ['en', 'en-US', 'en-GB', 'en-AU', 'en-CA', 'en-NZ', 'en-IE', 'en-ZA',\n        'en-JM', null, 'en-BZ', 'en-TT', 'en-ZW', 'en-PH'],\n    10: ['es', 'es-ES', 'es-MX', null, 'es-GT', 'es-CR', 'es-PA', 'es-DO',\n        'es-VE', 'es-CO', 'es-PE', 'es-AR', 'es-EC', 'es-CL', 'es-UY', 'es-PY',\n        'es-BO', 'es-SV', 'es-HN', 'es-NI', 'es-PR'],\n    11: ['fi'], 12: ['fr', 'fr-FR', 'fr-BE', 'fr-CA', 'fr-CH', 'fr-LU', 'fr-MC'],\n    13: ['he'], 14: ['hu'], 15: ['is'], 16: ['it', 'it-IT', 'it-CH'],\n    17: ['ja'], 18: ['ko'], 19: ['nl', 'nl-NL', 'nl-BE'], 20: ['no', 'nb', 'nn'],\n    21: ['pl'], 22: ['pt', 'pt-BR', 'pt-PT'], 23: ['rm'], 24: ['ro'], 25: ['ru'],\n    26: ['hr', null, 'sr'], 27: ['sk'], 28: ['sq'], 29: ['sv', 'sv-SE', 'sv-FI'],\n    30: ['th'], 31: ['tr'], 32: ['ur'], 33: ['id'], 34: ['uk'], 35: ['be'],\n    36: ['sl'], 37: ['et'], 38: ['lv'], 39: ['lt'], 41: ['fa'], 42: ['vi'],\n    43: ['hy'], 44: ['az'], 45: ['eu'], 46: ['hsb'], 47: ['mk'], 48: ['st'],\n    49: ['ts'], 50: ['tn'], 52: ['xh'], 53: ['zu'], 54: ['af'], 55: ['ka'],\n    56: ['fo'], 57: ['hi'], 58: ['mt'], 59: ['se'], 62: ['ms'], 63: ['kk'],\n    65: ['sw'], 67: ['uz', null, 'uz-UZ'], 68: ['tt'], 69: ['bn'], 70: ['pa'],\n    71: ['gu'], 72: ['or'], 73: ['ta'], 74: ['te'], 75: ['kn'], 76: ['ml'],\n    77: ['as'], 78: ['mr'], 79: ['sa'], 82: ['cy', 'cy-GB'], 83: ['gl', 'gl-ES'],\n    87: ['kok'], 97: ['ne'], 98: ['fy'],\n}\n\nconst concatTypedArray = (a, b) => {\n    const result = new a.constructor(a.length + b.length)\n    result.set(a)\n    result.set(b, a.length)\n    return result\n}\nconst concatTypedArray3 = (a, b, c) => {\n    const result = new a.constructor(a.length + b.length + c.length)\n    result.set(a)\n    result.set(b, a.length)\n    result.set(c, a.length + b.length)\n    return result\n}\n\nconst decoder = new TextDecoder()\nconst getString = buffer => decoder.decode(buffer)\nconst getUint = buffer => {\n    if (!buffer) return\n    const l = buffer.byteLength\n    const func = l === 4 ? 'getUint32' : l === 2 ? 'getUint16' : 'getUint8'\n    return new DataView(buffer)[func](0)\n}\nconst getStruct = (def, buffer) => Object.fromEntries(Array.from(Object.entries(def))\n    .map(([key, [start, len, type]]) => [key,\n        (type === 'string' ? getString : getUint)(buffer.slice(start, start + len))]))\n\nconst getDecoder = x => new TextDecoder(MOBI_ENCODING[x])\n\nconst getVarLen = (byteArray, i = 0) => {\n    let value = 0, length = 0\n    for (const byte of byteArray.subarray(i, i + 4)) {\n        value = (value << 7) | (byte & 0b111_1111) >>> 0\n        length++\n        if (byte & 0b1000_0000) break\n    }\n    return { value, length }\n}\n\n// variable-length quantity, but read from the end of data\nconst getVarLenFromEnd = byteArray => {\n    let value = 0\n    for (const byte of byteArray.subarray(-4)) {\n        // `byte & 0b1000_0000` indicates the start of value\n        if (byte & 0b1000_0000) value = 0\n        value = (value << 7) | (byte & 0b111_1111)\n    }\n    return value\n}\n\nconst countBitsSet = x => {\n    let count = 0\n    for (; x > 0; x = x >> 1) if ((x & 1) === 1) count++\n    return count\n}\n\nconst countUnsetEnd = x => {\n    let count = 0\n    while ((x & 1) === 0) x = x >> 1, count++\n    return count\n}\n\nconst decompressPalmDOC = array => {\n    let output = []\n    for (let i = 0; i < array.length; i++) {\n        const byte = array[i]\n        if (byte === 0) output.push(0) // uncompressed literal, just copy it\n        else if (byte <= 8) // copy next 1-8 bytes\n            for (const x of array.subarray(i + 1, (i += byte) + 1))\n                output.push(x)\n        else if (byte <= 0b0111_1111) output.push(byte) // uncompressed literal\n        else if (byte <= 0b1011_1111) {\n            // 1st and 2nd bits are 10, meaning this is a length-distance pair\n            // read next byte and combine it with current byte\n            const bytes = (byte << 8) | array[i++ + 1]\n            // the 3rd to 13th bits encode distance\n            const distance = (bytes & 0b0011_1111_1111_1111) >>> 3\n            // the last 3 bits, plus 3, is the length to copy\n            const length = (bytes & 0b111) + 3\n            for (let j = 0; j < length; j++)\n                output.push(output[output.length - distance])\n        }\n        // compressed from space plus char\n        else output.push(32, byte ^ 0b1000_0000)\n    }\n    return Uint8Array.from(output)\n}\n\nconst read32Bits = (byteArray, from) => {\n    const startByte = from >> 3\n    const end = from + 32\n    const endByte = end >> 3\n    let bits = 0n\n    for (let i = startByte; i <= endByte; i++)\n        bits = bits << 8n | BigInt(byteArray[i] ?? 0)\n    return (bits >> (8n - BigInt(end & 7))) & 0xffffffffn\n}\n\nconst huffcdic = async (mobi, loadRecord) => {\n    const huffRecord = await loadRecord(mobi.huffcdic)\n    const { magic, offset1, offset2 } = getStruct(HUFF_HEADER, huffRecord)\n    if (magic !== 'HUFF') throw new Error('Invalid HUFF record')\n\n    // table1 is indexed by byte value\n    const table1 = Array.from({ length: 256 }, (_, i) => offset1 + i * 4)\n        .map(offset => getUint(huffRecord.slice(offset, offset + 4)))\n        .map(x => [x & 0b1000_0000, x & 0b1_1111, x >>> 8])\n\n    // table2 is indexed by code length\n    const table2 = [null].concat(Array.from({ length: 32 }, (_, i) => offset2 + i * 8)\n        .map(offset => [\n            getUint(huffRecord.slice(offset, offset + 4)),\n            getUint(huffRecord.slice(offset + 4, offset + 8))]))\n\n    const dictionary = []\n    for (let i = 1; i < mobi.numHuffcdic; i++) {\n        const record = await loadRecord(mobi.huffcdic + i)\n        const cdic = getStruct(CDIC_HEADER, record)\n        if (cdic.magic !== 'CDIC') throw new Error('Invalid CDIC record')\n        // `numEntries` is the total number of dictionary data across CDIC records\n        // so `n` here is the number of entries in *this* record\n        const n = Math.min(1 << cdic.codeLength, cdic.numEntries - dictionary.length)\n        const buffer = record.slice(cdic.length)\n        for (let i = 0; i < n; i++) {\n            const offset = getUint(buffer.slice(i * 2, i * 2 + 2))\n            const x = getUint(buffer.slice(offset, offset + 2))\n            const length = x & 0x7fff\n            const decompressed = x & 0x8000\n            const value = new Uint8Array(\n                buffer.slice(offset + 2, offset + 2 + length))\n            dictionary.push([value, decompressed])\n        }\n    }\n\n    const decompress = byteArray => {\n        let output = new Uint8Array()\n        const bitLength = byteArray.byteLength * 8\n        for (let i = 0; i < bitLength;) {\n            const bits = Number(read32Bits(byteArray, i))\n            let [found, codeLength, value] = table1[bits >>> 24]\n            if (!found) {\n                while (bits >>> (32 - codeLength) < table2[codeLength][0])\n                    codeLength += 1\n                value = table2[codeLength][1]\n            }\n            if ((i += codeLength) > bitLength) break\n\n            const code = value - (bits >>> (32 - codeLength))\n            let [result, decompressed] = dictionary[code]\n            if (!decompressed) {\n                // the result is itself compressed\n                result = decompress(result)\n                // cache the result for next time\n                dictionary[code] = [result, true]\n            }\n            output = concatTypedArray(output, result)\n        }\n        return output\n    }\n    return decompress\n}\n\nconst getIndexData = async (indxIndex, loadRecord) => {\n    const indxRecord = await loadRecord(indxIndex)\n    const indx = getStruct(INDX_HEADER, indxRecord)\n    if (indx.magic !== 'INDX') throw new Error('Invalid INDX record')\n    const decoder = getDecoder(indx.encoding)\n\n    const tagxBuffer = indxRecord.slice(indx.length)\n    const tagx = getStruct(TAGX_HEADER, tagxBuffer)\n    if (tagx.magic !== 'TAGX') throw new Error('Invalid TAGX section')\n    const numTags = (tagx.length - 12) / 4\n    const tagTable = Array.from({ length: numTags }, (_, i) =>\n        new Uint8Array(tagxBuffer.slice(12 + i * 4, 12 + i * 4 + 4)))\n\n    const cncx = {}\n    let cncxRecordOffset = 0\n    for (let i = 0; i < indx.numCncx; i++) {\n        const record = await loadRecord(indxIndex + indx.numRecords + i + 1)\n        const array = new Uint8Array(record)\n        for (let pos = 0; pos < array.byteLength;) {\n            const index = pos\n            const { value, length } = getVarLen(array, pos)\n            pos += length\n            const result = record.slice(pos, pos + value)\n            pos += value\n            cncx[cncxRecordOffset + index] = decoder.decode(result)\n        }\n        cncxRecordOffset += 0x10000\n    }\n\n    const table = []\n    for (let i = 0; i < indx.numRecords; i++) {\n        const record = await loadRecord(indxIndex + 1 + i)\n        const array = new Uint8Array(record)\n        const indx = getStruct(INDX_HEADER, record)\n        if (indx.magic !== 'INDX') throw new Error('Invalid INDX record')\n        for (let j = 0; j < indx.numRecords; j++) {\n            const offsetOffset = indx.idxt + 4 + 2 * j\n            const offset = getUint(record.slice(offsetOffset, offsetOffset + 2))\n\n            const length = getUint(record.slice(offset, offset + 1))\n            const name = getString(record.slice(offset + 1, offset + 1 + length))\n\n            const tags = []\n            const startPos = offset + 1 + length\n            let controlByteIndex = 0\n            let pos = startPos + tagx.numControlBytes\n            for (const [tag, numValues, mask, end] of tagTable) {\n                if (end & 1) {\n                    controlByteIndex++\n                    continue\n                }\n                const offset = startPos + controlByteIndex\n                const value = getUint(record.slice(offset, offset + 1)) & mask\n                if (value === mask) {\n                    if (countBitsSet(mask) > 1) {\n                        const { value, length } = getVarLen(array, pos)\n                        tags.push([tag, null, value, numValues])\n                        pos += length\n                    } else tags.push([tag, 1, null, numValues])\n                } else tags.push([tag, value >> countUnsetEnd(mask), null, numValues])\n            }\n\n            const tagMap = {}\n            for (const [tag, valueCount, valueBytes, numValues] of tags) {\n                const values = []\n                if (valueCount != null) {\n                    for (let i = 0; i < valueCount * numValues; i++) {\n                        const { value, length } = getVarLen(array, pos)\n                        values.push(value)\n                        pos += length\n                    }\n                } else {\n                    let count = 0\n                    while (count < valueBytes) {\n                        const { value, length } = getVarLen(array, pos)\n                        values.push(value)\n                        pos += length\n                        count += length\n                    }\n                }\n                tagMap[tag] = values\n            }\n            table.push({ name, tagMap })\n        }\n    }\n    return { table, cncx }\n}\n\nconst getNCX = async (indxIndex, loadRecord) => {\n    const { table, cncx } = await getIndexData(indxIndex, loadRecord)\n    const items = table.map(({ tagMap }, index) => ({\n        index,\n        offset: tagMap[1]?.[0],\n        size: tagMap[2]?.[0],\n        label: cncx[tagMap[3]] ?? '',\n        headingLevel: tagMap[4]?.[0],\n        pos: tagMap[6],\n        parent: tagMap[21]?.[0],\n        firstChild: tagMap[22]?.[0],\n        lastChild: tagMap[23]?.[0],\n    }))\n    const getChildren = item => {\n        if (item.firstChild == null) return item\n        item.children = items.filter(x => x.parent === item.index).map(getChildren)\n        return item\n    }\n    return items.filter(item => item.headingLevel === 0).map(getChildren)\n}\n\nconst getEXTH = (buf, encoding) => {\n    const { magic, count } = getStruct(EXTH_HEADER, buf)\n    if (magic !== 'EXTH') throw new Error('Invalid EXTH header')\n    const decoder = getDecoder(encoding)\n    const results = {}\n    let offset = 12\n    for (let i = 0; i < count; i++) {\n        const type = getUint(buf.slice(offset, offset + 4))\n        const length = getUint(buf.slice(offset + 4, offset + 8))\n        if (type in EXTH_RECORD_TYPE) {\n            const [name, typ, many] = EXTH_RECORD_TYPE[type]\n            const data = buf.slice(offset + 8, offset + length)\n            const value = typ === 'uint' ? getUint(data) : decoder.decode(data)\n            if (many) {\n                results[name] ??= []\n                results[name].push(value)\n            } else results[name] = value\n        }\n        offset += length\n    }\n    return results\n}\n\nconst getFont = async (buf, unzlib) => {\n    const { flags, dataStart, keyLength, keyStart } = getStruct(FONT_HEADER, buf)\n    const array = new Uint8Array(buf.slice(dataStart))\n    // deobfuscate font\n    if (flags & 0b10) {\n        const bytes = keyLength === 16 ? 1024 : 1040\n        const key = new Uint8Array(buf.slice(keyStart, keyStart + keyLength))\n        const length = Math.min(bytes, array.length)\n        for (var i = 0; i < length; i++) array[i] = array[i] ^ key[i % key.length]\n    }\n    // decompress font\n    if (flags & 1) try {\n        return await unzlib(array)\n    } catch (e) {\n        console.warn(e)\n        console.warn('Failed to decompress font')\n    }\n    return array\n}\n\nexport const isMOBI = async file => {\n    const magic = getString(await file.slice(60, 68).arrayBuffer())\n    return magic === 'BOOKMOBI'// || magic === 'TEXtREAd'\n}\n\nclass PDB {\n    #file\n    #offsets\n    pdb\n    async open(file) {\n        this.#file = file\n        const pdb = getStruct(PDB_HEADER, await file.slice(0, 78).arrayBuffer())\n        this.pdb = pdb\n        const buffer = await file.slice(78, 78 + pdb.numRecords * 8).arrayBuffer()\n        // get start and end offsets for each record\n        this.#offsets = Array.from({ length: pdb.numRecords },\n            (_, i) => getUint(buffer.slice(i * 8, i * 8 + 4)))\n            .map((x, i, a) => [x, a[i + 1]])\n    }\n    loadRecord(index) {\n        const offsets = this.#offsets[index]\n        if (!offsets) throw new RangeError('Record index out of bounds')\n        return this.#file.slice(...offsets).arrayBuffer()\n    }\n    async loadMagic(index) {\n        const start = this.#offsets[index][0]\n        return getString(await this.#file.slice(start, start + 4).arrayBuffer())\n    }\n}\n\nexport class MOBI extends PDB {\n    #start = 0\n    #resourceStart\n    #decoder\n    #encoder\n    #decompress\n    #removeTrailingEntries\n    constructor({ unzlib }) {\n        super()\n        this.unzlib = unzlib\n    }\n    async open(file) {\n        await super.open(file)\n        // TODO: if (this.pdb.type === 'TEXt')\n        this.headers = this.#getHeaders(await super.loadRecord(0))\n        this.#resourceStart = this.headers.mobi.resourceStart\n        let isKF8 = this.headers.mobi.version >= 8\n        if (!isKF8) {\n            const boundary = this.headers.exth?.boundary\n            if (boundary < 0xffffffff) try {\n                // it's a \"combo\" MOBI/KF8 file; try to open the KF8 part\n                this.headers = this.#getHeaders(await super.loadRecord(boundary))\n                this.#start = boundary\n                isKF8 = true\n            } catch (e) {\n                console.warn(e)\n                console.warn('Failed to open KF8; falling back to MOBI')\n            }\n        }\n        await this.#setup()\n        return isKF8 ? new KF8(this).init() : new MOBI6(this).init()\n    }\n    #getHeaders(buf) {\n        const palmdoc = getStruct(PALMDOC_HEADER, buf)\n        const mobi = getStruct(MOBI_HEADER, buf)\n        if (mobi.magic !== 'MOBI') throw new Error('Missing MOBI header')\n\n        const { titleOffset, titleLength, localeLanguage, localeRegion } = mobi\n        mobi.title = buf.slice(titleOffset, titleOffset + titleLength)\n        const lang = MOBI_LANG[localeLanguage]\n        mobi.language = lang?.[localeRegion >> 2] ?? lang?.[0]\n\n        const exth = mobi.exthFlag & 0b100_0000\n            ? getEXTH(buf.slice(mobi.length + 16), mobi.encoding) : null\n        const kf8 = mobi.version >= 8 ? getStruct(KF8_HEADER, buf) : null\n        return { palmdoc, mobi, exth, kf8 }\n    }\n    async #setup() {\n        const { palmdoc, mobi } = this.headers\n        this.#decoder = getDecoder(mobi.encoding)\n        // `TextEncoder` only supports UTF-8\n        // we are only encoding ASCII anyway, so I think it's fine\n        this.#encoder = new TextEncoder()\n\n        // set up decompressor\n        const { compression } = palmdoc\n        this.#decompress = compression === 1 ? f => f\n            : compression === 2 ? decompressPalmDOC\n            : compression === 17480 ? await huffcdic(mobi, this.loadRecord.bind(this))\n            : null\n        if (!this.#decompress) throw new Error('Unknown compression type')\n\n        // set up function for removing trailing bytes\n        const { trailingFlags } = mobi\n        const multibyte = trailingFlags & 1\n        const numTrailingEntries = countBitsSet(trailingFlags >>> 1)\n        this.#removeTrailingEntries = array => {\n            for (let i = 0; i < numTrailingEntries; i++) {\n                const length = getVarLenFromEnd(array)\n                array = array.subarray(0, -length)\n            }\n            if (multibyte) {\n                const length = (array[array.length - 1] & 0b11) + 1\n                array = array.subarray(0, -length)\n            }\n            return array\n        }\n    }\n    decode(...args) {\n        return this.#decoder.decode(...args)\n    }\n    encode(...args) {\n        return this.#encoder.encode(...args)\n    }\n    loadRecord(index) {\n        return super.loadRecord(this.#start + index)\n    }\n    loadMagic(index) {\n        return super.loadMagic(this.#start + index)\n    }\n    loadText(index) {\n        return this.loadRecord(index + 1)\n            .then(buf => new Uint8Array(buf))\n            .then(this.#removeTrailingEntries)\n            .then(this.#decompress)\n    }\n    async loadResource(index) {\n        const buf = await super.loadRecord(this.#resourceStart + index)\n        const magic = getString(buf.slice(0, 4))\n        if (magic === 'FONT') return getFont(buf, this.unzlib)\n        if (magic === 'VIDE' || magic === 'AUDI') return buf.slice(12)\n        return buf\n    }\n    getNCX() {\n        const index = this.headers.mobi.indx\n        if (index < 0xffffffff) return getNCX(index, this.loadRecord.bind(this))\n    }\n    getMetadata() {\n        const { mobi, exth } = this.headers\n        return {\n            identifier: mobi.uid.toString(),\n            title: unescapeHTML(exth?.title || this.decode(mobi.title)),\n            author: exth?.creator?.map(unescapeHTML),\n            publisher: unescapeHTML(exth?.publisher),\n            language: exth?.language ?? mobi.language,\n            published: exth?.date,\n            description: unescapeHTML(exth?.description),\n            subject: exth?.subject?.map(unescapeHTML),\n            rights: unescapeHTML(exth?.rights),\n        }\n    }\n    async getCover() {\n        const { exth } = this.headers\n        const offset = exth?.coverOffset < 0xffffffff ? exth?.coverOffset\n            : exth?.thumbnailOffset < 0xffffffff ? exth?.thumbnailOffset : null\n        if (offset != null) {\n            const buf = await this.loadResource(offset)\n            return new Blob([buf])\n        }\n    }\n}\n\nconst mbpPagebreakRegex = /<\\s*(?:mbp:)?pagebreak[^>]*>/gi\nconst fileposRegex = /<[^<>]+filepos=['\"]{0,1}(\\d+)[^<>]*>/gi\n\nconst getIndent = el => {\n    let x = 0\n    while (el) {\n        const parent = el.parentElement\n        if (parent) {\n            const tag = parent.tagName.toLowerCase()\n            if (tag === 'p') x += 1.5\n            else if (tag === 'blockquote') x += 2\n        }\n        el = parent\n    }\n    return x\n}\n\nclass MOBI6 {\n    parser = new DOMParser()\n    serializer = new XMLSerializer()\n    #resourceCache = new Map()\n    #textCache = new Map()\n    #cache = new Map()\n    #sections\n    #fileposList = []\n    #type = MIME.HTML\n    constructor(mobi) {\n        this.mobi = mobi\n    }\n    async init() {\n        // load all text records in an array\n        let array = new Uint8Array()\n        for (let i = 0; i < this.mobi.headers.palmdoc.numTextRecords; i++)\n            array = concatTypedArray(array, await this.mobi.loadText(i))\n\n        // convert to string so we can use regex\n        // note that `filepos` are byte offsets\n        // so it needs to preserve each byte as a separate character\n        // (see https://stackoverflow.com/q/50198017)\n        const str = Array.from(new Uint8Array(array),\n            c => String.fromCharCode(c)).join('')\n\n        // split content into sections at each `<mbp:pagebreak>`\n        this.#sections = [0]\n            .concat(Array.from(str.matchAll(mbpPagebreakRegex), m => m.index))\n            .map((x, i, a) => str.slice(x, a[i + 1]))\n            // recover the original raw bytes\n            .map(str => Uint8Array.from(str, x => x.charCodeAt(0)))\n            .map(raw => ({ book: this, raw }))\n            // get start and end filepos for each section\n            .reduce((arr, x) => {\n                const last = arr[arr.length - 1]\n                x.start = last?.end ?? 0\n                x.end = x.start + x.raw.byteLength\n                return arr.concat(x)\n            }, [])\n\n        this.sections = this.#sections.map((section, index) => ({\n            id: index,\n            load: () => this.loadSection(section),\n            createDocument: () => this.createDocument(section),\n            size: section.end - section.start,\n        }))\n\n        try {\n            this.landmarks = await this.getGuide()\n            const tocHref = this.landmarks\n                .find(({ type }) => type?.includes('toc'))?.href\n            if (tocHref) {\n                const { index } = this.resolveHref(tocHref)\n                const doc = await this.sections[index].createDocument()\n                let lastItem\n                let lastLevel = 0\n                let lastIndent = 0\n                const lastLevelOfIndent = new Map()\n                const lastParentOfLevel = new Map()\n                this.toc = Array.from(doc.querySelectorAll('a[filepos]'))\n                    .reduce((arr, a) => {\n                        const indent = getIndent(a)\n                        const item = {\n                            label: a.innerText?.trim(),\n                            href: `filepos:${a.getAttribute('filepos')}`,\n                        }\n                        const level = indent > lastIndent ? lastLevel + 1\n                            : indent === lastIndent ? lastLevel\n                            : lastLevelOfIndent.get(indent) ?? Math.max(0, lastLevel - 1)\n                        if (level > lastLevel) {\n                            if (lastItem) {\n                                lastItem.subitems ??= []\n                                lastItem.subitems.push(item)\n                                lastParentOfLevel.set(level, lastItem)\n                            }\n                            else arr.push(item)\n                        }\n                        else {\n                            const parent = lastParentOfLevel.get(level)\n                            if (parent) parent.subitems.push(item)\n                            else arr.push(item)\n                        }\n                        lastItem = item\n                        lastLevel = level\n                        lastIndent = indent\n                        lastLevelOfIndent.set(indent, level)\n                        return arr\n                    }, [])\n            }\n        } catch(e) {\n            console.warn(e)\n        }\n\n        // get list of all `filepos` references in the book,\n        // which will be used to insert anchor elements\n        // because only then can they be referenced in the DOM\n        this.#fileposList = [...new Set(\n            Array.from(str.matchAll(fileposRegex), m => m[1]))]\n            .map(filepos => ({ filepos, number: Number(filepos) }))\n            .sort((a, b) => a.number - b.number)\n\n        this.metadata = this.mobi.getMetadata()\n        this.getCover = this.mobi.getCover.bind(this.mobi)\n        return this\n    }\n    async getGuide() {\n        const doc = await this.createDocument(this.#sections[0])\n        return Array.from(doc.getElementsByTagName('reference'), ref => ({\n            label: ref.getAttribute('title'),\n            type: ref.getAttribute('type')?.split(/\\s/),\n            href: `filepos:${ref.getAttribute('filepos')}`,\n        }))\n    }\n    async loadResource(index) {\n        if (this.#resourceCache.has(index)) return this.#resourceCache.get(index)\n        const raw = await this.mobi.loadResource(index)\n        const url = URL.createObjectURL(new Blob([raw]))\n        this.#resourceCache.set(index, url)\n        return url\n    }\n    async loadRecindex(recindex) {\n        return this.loadResource(Number(recindex) - 1)\n    }\n    async replaceResources(doc) {\n        for (const img of doc.querySelectorAll('img[recindex]')) {\n            const recindex = img.getAttribute('recindex')\n            try {\n                img.src = await this.loadRecindex(recindex)\n            } catch {\n                console.warn(`Failed to load image ${recindex}`)\n            }\n        }\n        for (const media of doc.querySelectorAll('[mediarecindex]')) {\n            const mediarecindex = media.getAttribute('mediarecindex')\n            const recindex = media.getAttribute('recindex')\n            try {\n                media.src = await this.loadRecindex(mediarecindex)\n                if (recindex) media.poster = await this.loadRecindex(recindex)\n            } catch {\n                console.warn(`Failed to load media ${mediarecindex}`)\n            }\n        }\n        for (const a of doc.querySelectorAll('[filepos]')) {\n            const filepos = a.getAttribute('filepos')\n            a.href = `filepos:${filepos}`\n        }\n    }\n    async loadText(section) {\n        if (this.#textCache.has(section)) return this.#textCache.get(section)\n        const { raw } = section\n\n        // insert anchor elements for each `filepos`\n        const fileposList = this.#fileposList\n            .filter(({ number }) => number >= section.start && number < section.end)\n            .map(obj => ({ ...obj, offset: obj.number - section.start }))\n        let arr = raw\n        if (fileposList.length) {\n            arr = raw.subarray(0, fileposList[0].offset)\n            fileposList.forEach(({ filepos, offset }, i) => {\n                const next = fileposList[i + 1]\n                const a = this.mobi.encode(`<a id=\"filepos${filepos}\"></a>`)\n                arr = concatTypedArray3(arr, a, raw.subarray(offset, next?.offset))\n            })\n        }\n        const str = this.mobi.decode(arr).replaceAll(mbpPagebreakRegex, '')\n        this.#textCache.set(section, str)\n        return str\n    }\n    async createDocument(section) {\n        const str = await this.loadText(section)\n        return this.parser.parseFromString(str, this.#type)\n    }\n    async loadSection(section) {\n        if (this.#cache.has(section)) return this.#cache.get(section)\n        const doc = await this.createDocument(section)\n\n        // inject default stylesheet\n        const style = doc.createElement('style')\n        doc.head.append(style)\n        // blockquotes in MOBI seem to have only a small left margin by default\n        // many books seem to rely on this, as it's the only way to set margin\n        // (since there's no CSS)\n        style.append(doc.createTextNode(`blockquote {\n            margin-block-start: 0;\n            margin-block-end: 0;\n            margin-inline-start: 1em;\n            margin-inline-end: 0;\n        }`))\n\n        await this.replaceResources(doc)\n        const result = this.serializer.serializeToString(doc)\n        const url = URL.createObjectURL(new Blob([result], { type: this.#type }))\n        this.#cache.set(section, url)\n        return url\n    }\n    resolveHref(href) {\n        const filepos = href.match(/filepos:(.*)/)[1]\n        const number = Number(filepos)\n        const index = this.#sections.findIndex(section => section.end > number)\n        const anchor = doc => doc.getElementById(`filepos${filepos}`)\n        return { index, anchor }\n    }\n    splitTOCHref(href) {\n        const filepos = href.match(/filepos:(.*)/)[1]\n        const number = Number(filepos)\n        const index = this.#sections.findIndex(section => section.end > number)\n        return [index, `filepos${filepos}`]\n    }\n    getTOCFragment(doc, id) {\n        return doc.getElementById(id)\n    }\n    isExternal(uri) {\n        return /^(?!blob|filepos)\\w+:/i.test(uri)\n    }\n    destroy() {\n        for (const url of this.#resourceCache.values()) URL.revokeObjectURL(url)\n        for (const url of this.#cache.values()) URL.revokeObjectURL(url)\n    }\n}\n\n// handlers for `kindle:` uris\nconst kindleResourceRegex = /kindle:(flow|embed):(\\w+)(?:\\?mime=(\\w+\\/[-+.\\w]+))?/\nconst kindlePosRegex = /kindle:pos:fid:(\\w+):off:(\\w+)/\nconst parseResourceURI = str => {\n    const [resourceType, id, type] = str.match(kindleResourceRegex).slice(1)\n    return { resourceType, id: parseInt(id, 32), type }\n}\nconst parsePosURI = str => {\n    const [fid, off] = str.match(kindlePosRegex).slice(1)\n    return { fid: parseInt(fid, 32), off: parseInt(off, 32) }\n}\nconst makePosURI = (fid = 0, off = 0) =>\n    `kindle:pos:fid:${fid.toString(32).toUpperCase().padStart(4, '0')\n    }:off:${off.toString(32).toUpperCase().padStart(10, '0')}`\n\n// `kindle:pos:` links are originally links that contain fragments identifiers\n// so there should exist an element with `id` or `name`\n// otherwise try to find one with an `aid` attribute\nconst getFragmentSelector = str => {\n    const match = str.match(/\\s(id|name|aid)\\s*=\\s*['\"]([^'\"]*)['\"]/i)\n    if (!match) return\n    const [, attr, value] = match\n    return `[${attr}=\"${CSS.escape(value)}\"]`\n}\n\n// replace asynchronously and sequentially\nconst replaceSeries = async (str, regex, f) => {\n    const matches = []\n    str.replace(regex, (...args) => (matches.push(args), null))\n    const results = []\n    for (const args of matches) results.push(await f(...args))\n    return str.replace(regex, () => results.shift())\n}\n\nconst getPageSpread = properties => {\n    for (const p of properties) {\n        if (p === 'page-spread-left' || p === 'rendition:page-spread-left')\n            return 'left'\n        if (p === 'page-spread-right' || p === 'rendition:page-spread-right')\n            return 'right'\n        if (p === 'rendition:page-spread-center') return 'center'\n    }\n}\n\nclass KF8 {\n    parser = new DOMParser()\n    serializer = new XMLSerializer()\n    #cache = new Map()\n    #fragmentOffsets = new Map()\n    #fragmentSelectors = new Map()\n    #tables = {}\n    #sections\n    #fullRawLength\n    #rawHead = new Uint8Array()\n    #rawTail = new Uint8Array()\n    #lastLoadedHead = -1\n    #lastLoadedTail = -1\n    #type = MIME.XHTML\n    #inlineMap = new Map()\n    constructor(mobi) {\n        this.mobi = mobi\n    }\n    async init() {\n        const loadRecord = this.mobi.loadRecord.bind(this.mobi)\n        const { kf8 } = this.mobi.headers\n\n        try {\n            const fdstBuffer = await loadRecord(kf8.fdst)\n            const fdst = getStruct(FDST_HEADER, fdstBuffer)\n            if (fdst.magic !== 'FDST') throw new Error('Missing FDST record')\n            const fdstTable = Array.from({ length: fdst.numEntries },\n                (_, i) => 12 + i * 8)\n                .map(offset => [\n                    getUint(fdstBuffer.slice(offset, offset + 4)),\n                    getUint(fdstBuffer.slice(offset + 4, offset + 8))])\n            this.#tables.fdstTable = fdstTable\n            this.#fullRawLength = fdstTable[fdstTable.length - 1][1]\n        } catch {}\n\n        const skelTable = (await getIndexData(kf8.skel, loadRecord)).table\n            .map(({ name, tagMap }, index) => ({\n                index, name,\n                numFrag: tagMap[1][0],\n                offset: tagMap[6][0],\n                length: tagMap[6][1],\n            }))\n        const fragData = await getIndexData(kf8.frag, loadRecord)\n        const fragTable = fragData.table.map(({ name, tagMap }) => ({\n            insertOffset: parseInt(name),\n            selector: fragData.cncx[tagMap[2][0]],\n            index: tagMap[4][0],\n            offset: tagMap[6][0],\n            length: tagMap[6][1],\n        }))\n        this.#tables.skelTable = skelTable\n        this.#tables.fragTable = fragTable\n\n        this.#sections = skelTable.reduce((arr, skel) => {\n            const last = arr[arr.length - 1]\n            const fragStart = last?.fragEnd ?? 0, fragEnd = fragStart + skel.numFrag\n            const frags = fragTable.slice(fragStart, fragEnd)\n            const length = skel.length + frags.map(f => f.length).reduce((a, b) => a + b)\n            const totalLength = (last?.totalLength ?? 0) + length\n            return arr.concat({ skel, frags, fragEnd, length, totalLength })\n        }, [])\n\n        const resources = await this.getResourcesByMagic(['RESC', 'PAGE'])\n        const pageSpreads = new Map()\n        if (resources.RESC) {\n            const buf = await this.mobi.loadRecord(resources.RESC)\n            const str = this.mobi.decode(buf.slice(16)).replace(/\\0/g, '')\n            // the RESC record lacks the root `<package>` element\n            // but seem to be otherwise valid XML\n            const index = str.search(/\\?>/)\n            const xmlStr = `<package>${str.slice(index)}</package>`\n            const opf = this.parser.parseFromString(xmlStr, MIME.XML)\n            for (const $itemref of opf.querySelectorAll('spine > itemref')) {\n                const i = parseInt($itemref.getAttribute('skelid'))\n                pageSpreads.set(i, getPageSpread(\n                    $itemref.getAttribute('properties')?.split(' ') ?? []))\n            }\n        }\n\n        this.sections = this.#sections.map((section, index) =>\n            section.frags.length ? ({\n                id: index,\n                load: () => this.loadSection(section),\n                createDocument: () => this.createDocument(section),\n                size: section.length,\n                pageSpread: pageSpreads.get(index),\n            }) : ({ linear: 'no' }))\n\n        try {\n            const ncx = await this.mobi.getNCX()\n            const map = ({ label, pos, children }) => {\n                const [fid, off] = pos\n                const href = makePosURI(fid, off)\n                const arr = this.#fragmentOffsets.get(fid)\n                if (arr) arr.push(off)\n                else this.#fragmentOffsets.set(fid, [off])\n                return { label: unescapeHTML(label), href, subitems: children?.map(map) }\n            }\n            this.toc = ncx?.map(map)\n            this.landmarks = await this.getGuide()\n        } catch(e) {\n            console.warn(e)\n        }\n\n        const { exth } = this.mobi.headers\n        this.dir = exth.pageProgressionDirection\n        this.rendition = {\n            layout: exth.fixedLayout === 'true' ? 'pre-paginated' : 'reflowable',\n            viewport: Object.fromEntries(exth.originalResolution\n                ?.split('x')?.slice(0, 2)\n                ?.map((x, i) => [i ? 'height' : 'width', x]) ?? []),\n        }\n\n        this.metadata = this.mobi.getMetadata()\n        this.getCover = this.mobi.getCover.bind(this.mobi)\n        return this\n    }\n    // is this really the only way of getting to RESC, PAGE, etc.?\n    async getResourcesByMagic(keys) {\n        const results = {}\n        const start = this.mobi.headers.kf8.resourceStart\n        const end = this.mobi.pdb.numRecords\n        for (let i = start; i < end; i++) {\n            try {\n                const magic = await this.mobi.loadMagic(i)\n                const match = keys.find(key => key === magic)\n                if (match) results[match] = i\n            } catch {}\n        }\n        return results\n    }\n    async getGuide() {\n        const index = this.mobi.headers.kf8.guide\n        if (index < 0xffffffff) {\n            const loadRecord = this.mobi.loadRecord.bind(this.mobi)\n            const { table, cncx } = await getIndexData(index, loadRecord)\n            return table.map(({ name, tagMap }) => ({\n                label: cncx[tagMap[1][0]] ?? '',\n                type: name?.split(/\\s/),\n                href: makePosURI(tagMap[6]?.[0] ?? tagMap[3]?.[0]),\n            }))\n        }\n    }\n    async loadResourceBlob(str) {\n        const { resourceType, id, type } = parseResourceURI(str)\n        const raw = resourceType === 'flow' ? await this.loadFlow(id)\n            : await this.mobi.loadResource(id - 1)\n        const result = [MIME.XHTML, MIME.HTML, MIME.CSS, MIME.SVG].includes(type)\n            ? await this.replaceResources(this.mobi.decode(raw)) : raw\n        const doc = type === MIME.SVG ? this.parser.parseFromString(result, type) : null\n        return [new Blob([result], { type }),\n            // SVG wrappers need to be inlined\n            // as browsers don't allow external resources when loading SVG as an image\n            doc?.getElementsByTagNameNS('http://www.w3.org/2000/svg', 'image')?.length\n                ? doc.documentElement : null]\n    }\n    async loadResource(str) {\n        if (this.#cache.has(str)) return this.#cache.get(str)\n        const [blob, inline] = await this.loadResourceBlob(str)\n        const url = inline ? str : URL.createObjectURL(blob)\n        if (inline) this.#inlineMap.set(url, inline)\n        this.#cache.set(str, url)\n        return url\n    }\n    replaceResources(str) {\n        const regex = new RegExp(kindleResourceRegex, 'g')\n        return replaceSeries(str, regex, this.loadResource.bind(this))\n    }\n    // NOTE: there doesn't seem to be a way to access text randomly?\n    // how to know the decompressed size of the records without decompressing?\n    // 4096 is just the maximum size\n    async loadRaw(start, end) {\n        // here we load either from the front or back until we have reached the\n        // required offsets; at worst you'd have to load half the book at once\n        const distanceHead = end - this.#rawHead.length\n        const distanceEnd = this.#fullRawLength == null ? Infinity\n            : (this.#fullRawLength - this.#rawTail.length) - start\n        // load from the start\n        if (distanceHead < 0 || distanceHead < distanceEnd) {\n            while (this.#rawHead.length < end) {\n                const index = ++this.#lastLoadedHead\n                const data = await this.mobi.loadText(index)\n                this.#rawHead = concatTypedArray(this.#rawHead, data)\n            }\n            return this.#rawHead.slice(start, end)\n        }\n        // load from the end\n        while (this.#fullRawLength - this.#rawTail.length > start) {\n            const index = this.mobi.headers.palmdoc.numTextRecords - 1\n                - (++this.#lastLoadedTail)\n            const data = await this.mobi.loadText(index)\n            this.#rawTail = concatTypedArray(data, this.#rawTail)\n        }\n        const rawTailStart = this.#fullRawLength - this.#rawTail.length\n        return this.#rawTail.slice(start - rawTailStart, end - rawTailStart)\n    }\n    loadFlow(index) {\n        if (index < 0xffffffff)\n            return this.loadRaw(...this.#tables.fdstTable[index])\n    }\n    async loadText(section) {\n        const { skel, frags, length } = section\n        const raw = await this.loadRaw(skel.offset, skel.offset + length)\n        let skeleton = raw.slice(0, skel.length)\n        for (const frag of frags) {\n            const insertOffset = frag.insertOffset - skel.offset\n            const offset = skel.length + frag.offset\n            const fragRaw = raw.slice(offset, offset + frag.length)\n            skeleton = concatTypedArray3(\n                skeleton.slice(0, insertOffset), fragRaw,\n                skeleton.slice(insertOffset))\n\n            const offsets = this.#fragmentOffsets.get(frag.index)\n            if (offsets) for (const offset of offsets) {\n                const str = this.mobi.decode(fragRaw).slice(offset)\n                const selector = getFragmentSelector(str)\n                this.#setFragmentSelector(frag.index, offset, selector)\n            }\n        }\n        return this.mobi.decode(skeleton)\n    }\n    async createDocument(section) {\n        const str = await this.loadText(section)\n        return this.parser.parseFromString(str, this.#type)\n    }\n    async loadSection(section) {\n        if (this.#cache.has(section)) return this.#cache.get(section)\n        const str = await this.loadText(section)\n        const replaced = await this.replaceResources(str)\n\n        // by default, type is XHTML; change to HTML if it's not valid XHTML\n        let doc = this.parser.parseFromString(replaced, this.#type)\n        if (doc.querySelector('parsererror')) {\n            this.#type = MIME.HTML\n            doc = this.parser.parseFromString(replaced, this.#type)\n        }\n        for (const [url, node] of this.#inlineMap) {\n            for (const el of doc.querySelectorAll(`img[src=\"${url}\"]`))\n                el.replaceWith(node)\n        }\n        const url = URL.createObjectURL(\n            new Blob([this.serializer.serializeToString(doc)], { type: this.#type }))\n        this.#cache.set(section, url)\n        return url\n    }\n    getIndexByFID(fid) {\n        return this.#sections.findIndex(section =>\n            section.frags.some(frag => frag.index === fid))\n    }\n    #setFragmentSelector(id, offset, selector) {\n        const map = this.#fragmentSelectors.get(id)\n        if (map) map.set(offset, selector)\n        else {\n            const map = new Map()\n            this.#fragmentSelectors.set(id, map)\n            map.set(offset, selector)\n        }\n    }\n    async resolveHref(href) {\n        const { fid, off } = parsePosURI(href)\n        const index = this.getIndexByFID(fid)\n        if (index < 0) return\n\n        const saved = this.#fragmentSelectors.get(fid)?.get(off)\n        if (saved) return { index, anchor: doc => doc.querySelector(saved) }\n\n        const { skel, frags } = this.#sections[index]\n        const frag = frags.find(frag => frag.index === fid)\n        const offset = skel.offset + skel.length + frag.offset\n        const fragRaw = await this.loadRaw(offset, offset + frag.length)\n        const str = this.mobi.decode(fragRaw).slice(off)\n        const selector = getFragmentSelector(str)\n        this.#setFragmentSelector(fid, off, selector)\n        const anchor = doc => doc.querySelector(selector)\n        return { index, anchor }\n    }\n    splitTOCHref(href) {\n        const pos = parsePosURI(href)\n        const index = this.getIndexByFID(pos.fid)\n        return [index, pos]\n    }\n    getTOCFragment(doc, { fid, off }) {\n        const selector = this.#fragmentSelectors.get(fid)?.get(off)\n        return doc.querySelector(selector)\n    }\n    isExternal(uri) {\n        return /^(?!blob|kindle)\\w+:/i.test(uri)\n    }\n    destroy() {\n        for (const url of this.#cache.values()) URL.revokeObjectURL(url)\n    }\n}\n"],"names":["_classPrivateFieldBase","e","t","hasOwnProperty","call","TypeError","id","_classPrivateFieldKey","unescapeHTML","str","textarea","document","createElement","innerHTML","value","MIME","XML","XHTML","HTML","CSS","SVG","PDB_HEADER","name","type","creator","numRecords","PALMDOC_HEADER","compression","numTextRecords","recordSize","encryption","MOBI_HEADER","magic","length","encoding","uid","version","titleOffset","titleLength","localeRegion","localeLanguage","resourceStart","huffcdic","numHuffcdic","exthFlag","trailingFlags","indx","KF8_HEADER","fdst","numFdst","frag","skel","guide","EXTH_HEADER","count","INDX_HEADER","idxt","language","total","ordt","ligt","numLigt","numCncx","TAGX_HEADER","numControlBytes","HUFF_HEADER","offset1","offset2","CDIC_HEADER","numEntries","codeLength","FDST_HEADER","FONT_HEADER","flags","dataStart","keyLength","keyStart","MOBI_ENCODING","EXTH_RECORD_TYPE","MOBI_LANG","concatTypedArray","a","b","result","constructor","set","concatTypedArray3","c","decoder","TextDecoder","getString","buffer","decode","getUint","l","byteLength","func","DataView","getStruct","def","Object","fromEntries","Array","from","entries","map","_ref","key","start","len","slice","getDecoder","x","getVarLen","byteArray","i","arguments","undefined","byte","subarray","getVarLenFromEnd","countBitsSet","countUnsetEnd","decompressPalmDOC","array","output","push","bytes","distance","j","Uint8Array","read32Bits","end","endByte","bits","_byteArray$i","BigInt","getIndexData","async","indxIndex","loadRecord","indxRecord","Error","tagxBuffer","tagx","numTags","tagTable","_","cncx","cncxRecordOffset","record","pos","index","table","offsetOffset","offset","tags","startPos","controlByteIndex","tag","numValues","mask","tagMap","valueCount","valueBytes","values","isMOBI","file","arrayBuffer","_file","_classPrivateFieldLooseKey","_offsets","PDB","defineProperty","writable","open","_classPrivateFieldLooseBase","this","pdb","offsets","RangeError","loadMagic","_start","_resourceStart","_decoder","_encoder","_decompress","_removeTrailingEntries","_getHeaders","_setup","MOBI","_ref3","unzlib","super","_setup2","_getHeaders2","headers","mobi","isKF8","_this$headers$exth","boundary","exth","console","warn","KF8","init","MOBI6","encode","loadText","then","buf","loadResource","Math","min","getFont","getNCX","items","_ref2","_tagMap$","_tagMap$2","_cncx$tagMap$","_tagMap$3","_tagMap$4","_tagMap$5","_tagMap$6","size","label","headingLevel","parent","firstChild","lastChild","getChildren","item","children","filter","bind","getMetadata","_exth$creator","_exth$language","_exth$subject","identifier","toString","title","author","publisher","published","date","description","subject","rights","getCover","coverOffset","thumbnailOffset","Blob","_lang","palmdoc","lang","getEXTH","results","typ","many","data","_results$name","kf8","TextEncoder","f","huffRecord","table1","table2","concat","dictionary","cdic","n","decompressed","decompress","bitLength","Number","found","code","multibyte","numTrailingEntries","mbpPagebreakRegex","fileposRegex","_resourceCache","_textCache","_cache","_sections","_fileposList","_type","parser","DOMParser","serializer","XMLSerializer","Map","String","fromCharCode","join","matchAll","m","charCodeAt","raw","book","reduce","arr","_last$end","last","sections","section","load","loadSection","createDocument","_this$landmarks$find","landmarks","getGuide","tocHref","find","_ref4","includes","href","resolveHref","doc","lastItem","lastLevel","lastIndent","lastLevelOfIndent","lastParentOfLevel","toc","querySelectorAll","_a$innerText","_lastLevelOfIndent$ge","indent","el","parentElement","tagName","toLowerCase","getIndent","innerText","trim","getAttribute","level","get","max","_lastItem","_lastItem$subitems","subitems","Set","filepos","number","sort","metadata","getElementsByTagName","ref","_ref$getAttribute","split","has","url","URL","createObjectURL","loadRecindex","recindex","replaceResources","img","src","media","mediarecindex","poster","fileposList","_ref5","obj","forEach","_ref6","next","replaceAll","parseFromString","style","head","append","createTextNode","serializeToString","match","findIndex","anchor","getElementById","splitTOCHref","getTOCFragment","isExternal","uri","test","destroy","revokeObjectURL","kindleResourceRegex","kindlePosRegex","parsePosURI","fid","off","parseInt","makePosURI","toUpperCase","padStart","getFragmentSelector","attr","escape","getPageSpread","properties","p","_cache2","_fragmentOffsets","_fragmentSelectors","_tables","_sections2","_fullRawLength","_rawHead","_rawTail","_lastLoadedHead","_lastLoadedTail","_type2","_inlineMap","_setFragmentSelector","_setFragmentSelector2","_exth$originalResolut","_exth$originalResolut2","_exth$originalResolut3","_exth$originalResolut4","fdstBuffer","fdstTable","skelTable","_ref7","numFrag","fragData","fragTable","_ref8","insertOffset","selector","_last$fragEnd","_last$totalLength","fragStart","fragEnd","frags","totalLength","resources","getResourcesByMagic","pageSpreads","RESC","replace","search","xmlStr","opf","$itemref","_$itemref$getAttribut","_$itemref$getAttribut2","pageSpread","linear","ncx","_ref9","dir","pageProgressionDirection","rendition","layout","fixedLayout","viewport","originalResolution","keys","_ref10","_cncx$tagMap$1$","_tagMap$6$","_tagMap$7","_tagMap$8","loadResourceBlob","_doc$getElementsByTag","resourceType","parseResourceURI","loadFlow","getElementsByTagNameNS","documentElement","blob","inline","regex","matches","_len","args","_key","shift","replaceSeries","RegExp","loadRaw","distanceHead","distanceEnd","Infinity","rawTailStart","skeleton","fragRaw","replaced","querySelector","node","replaceWith","getIndexByFID","some","_classPrivateFieldLoo","saved","_ref11","_classPrivateFieldLoo2"],"sourceRoot":""}