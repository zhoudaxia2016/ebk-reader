"use strict";(self.webpackChunkclient=self.webpackChunkclient||[]).push([[292],{7292:n=>{n.exports='(shebang) @keyword.directive\n\n(identifier) @variable\n\n((identifier) @type\n  (#lua-match? @type "^[A-Z]"))\n\n(const_item\n  name: (identifier) @constant)\n\n; Assume all-caps names are constants\n((identifier) @constant\n  (#lua-match? @constant "^[A-Z][A-Z%d_]*$"))\n\n; Other identifiers\n(type_identifier) @type\n\n(primitive_type) @type.builtin\n\n(field_identifier) @variable.member\n\n(shorthand_field_initializer\n  (identifier) @variable.member)\n\n(mod_item\n  name: (identifier) @module)\n\n(self) @variable.builtin\n\n(label\n  [\n    "\'"\n    (identifier)\n  ] @label)\n\n; Function definitions\n(function_item\n  (identifier) @function)\n\n(function_signature_item\n  (identifier) @function)\n\n(parameter\n  (identifier) @variable.parameter)\n\n(closure_parameters\n  (_) @variable.parameter)\n\n; Function calls\n(call_expression\n  function: (identifier) @function.call)\n\n(call_expression\n  function:\n    (scoped_identifier\n      (identifier) @function.call .))\n\n(call_expression\n  function:\n    (field_expression\n      field: (field_identifier) @function.call))\n\n(generic_function\n  function: (identifier) @function.call)\n\n(generic_function\n  function:\n    (scoped_identifier\n      name: (identifier) @function.call))\n\n(generic_function\n  function:\n    (field_expression\n      field: (field_identifier) @function.call))\n\n; Assume other uppercase names are enum constructors\n((field_identifier) @constant\n  (#lua-match? @constant "^[A-Z]"))\n\n(enum_variant\n  name: (identifier) @constant)\n\n; Assume that uppercase names in paths are types\n(scoped_identifier\n  path: (identifier) @module)\n\n(scoped_identifier\n  (scoped_identifier\n    name: (identifier) @module))\n\n(scoped_type_identifier\n  path: (identifier) @module)\n\n(scoped_type_identifier\n  path: (identifier) @type\n  (#lua-match? @type "^[A-Z]"))\n\n(scoped_type_identifier\n  (scoped_identifier\n    name: (identifier) @module))\n\n((scoped_identifier\n  path: (identifier) @type)\n  (#lua-match? @type "^[A-Z]"))\n\n((scoped_identifier\n  name: (identifier) @type)\n  (#lua-match? @type "^[A-Z]"))\n\n((scoped_identifier\n  name: (identifier) @constant)\n  (#lua-match? @constant "^[A-Z][A-Z%d_]*$"))\n\n((scoped_identifier\n  path: (identifier) @type\n  name: (identifier) @constant)\n  (#lua-match? @type "^[A-Z]")\n  (#lua-match? @constant "^[A-Z]"))\n\n((scoped_type_identifier\n  path: (identifier) @type\n  name: (type_identifier) @constant)\n  (#lua-match? @type "^[A-Z]")\n  (#lua-match? @constant "^[A-Z]"))\n\n[\n  (crate)\n  (super)\n] @module\n\n(scoped_use_list\n  path: (identifier) @module)\n\n(scoped_use_list\n  path:\n    (scoped_identifier\n      (identifier) @module))\n\n(use_list\n  (scoped_identifier\n    (identifier) @module\n    .\n    (_)))\n\n(use_list\n  (identifier) @type\n  (#lua-match? @type "^[A-Z]"))\n\n(use_as_clause\n  alias: (identifier) @type\n  (#lua-match? @type "^[A-Z]"))\n\n; Correct enum constructors\n(call_expression\n  function:\n    (scoped_identifier\n      "::"\n      name: (identifier) @constant)\n  (#lua-match? @constant "^[A-Z]"))\n\n; Assume uppercase names in a match arm are constants.\n((match_arm\n  pattern:\n    (match_pattern\n      (identifier) @constant))\n  (#lua-match? @constant "^[A-Z]"))\n\n((match_arm\n  pattern:\n    (match_pattern\n      (scoped_identifier\n        name: (identifier) @constant)))\n  (#lua-match? @constant "^[A-Z]"))\n\n((identifier) @constant.builtin\n  (#any-of? @constant.builtin "Some" "None" "Ok" "Err"))\n\n; Macro definitions\n"$" @function.macro\n\n(metavariable) @function.macro\n\n(macro_definition\n  "macro_rules!" @function.macro)\n\n; Attribute macros\n(attribute_item\n  (attribute\n    (identifier) @function.macro))\n\n(inner_attribute_item\n  (attribute\n    (identifier) @function.macro))\n\n(attribute\n  (scoped_identifier\n    (identifier) @function.macro .))\n\n; Derive macros (assume all arguments are types)\n; (attribute\n;   (identifier) @_name\n;   arguments: (attribute (attribute (identifier) @type))\n;   (#eq? @_name "derive"))\n; Function-like macros\n(macro_invocation\n  macro: (identifier) @function.macro)\n\n(macro_invocation\n  macro:\n    (scoped_identifier\n      (identifier) @function.macro .))\n\n; Literals\n[\n  (line_comment)\n  (block_comment)\n] @comment @spell\n\n((line_comment) @comment.documentation\n  (#lua-match? @comment.documentation "^///[^/]"))\n\n((line_comment) @comment.documentation\n  (#lua-match? @comment.documentation "^///$"))\n\n((line_comment) @comment.documentation\n  (#lua-match? @comment.documentation "^//!"))\n\n((block_comment) @comment.documentation\n  (#lua-match? @comment.documentation "^/[*][*][^*].*[*]/$"))\n\n((block_comment) @comment.documentation\n  (#lua-match? @comment.documentation "^/[*][!]"))\n\n(boolean_literal) @boolean\n\n(integer_literal) @number\n\n(float_literal) @number.float\n\n[\n  (raw_string_literal)\n  (string_literal)\n] @string\n\n(escape_sequence) @string.escape\n\n(char_literal) @character\n\n; Keywords\n[\n  "use"\n  "mod"\n] @keyword.import\n\n(use_as_clause\n  "as" @keyword.import)\n\n[\n  "default"\n  "enum"\n  "impl"\n  "let"\n  "move"\n  "pub"\n  "struct"\n  "trait"\n  "type"\n  "union"\n  "unsafe"\n  "where"\n] @keyword\n\n[\n  "async"\n  "await"\n] @keyword.coroutine\n\n"try" @keyword.exception\n\n([\n  "ref"\n  (mutable_specifier)\n] @type.qualifier (#set! "score" 10))\n\n[\n  "const"\n  "static"\n  "dyn"\n  "extern"\n] @keyword.storage\n\n(lifetime\n  [\n    "\'"\n    (identifier)\n  ] @keyword.storage.lifetime)\n\n"fn" @keyword.function\n\n[\n  "return"\n  "yield"\n] @keyword.return\n\n(type_cast_expression\n  "as" @keyword.operator)\n\n(qualified_type\n  "as" @keyword.operator)\n\n(use_list\n  (self) @module)\n\n(scoped_use_list\n  (self) @module)\n\n(scoped_identifier\n  [\n    (crate)\n    (super)\n    (self)\n  ] @module)\n\n(visibility_modifier\n  [\n    (crate)\n    (super)\n    (self)\n  ] @module)\n\n[\n  "if"\n  "else"\n  "match"\n] @keyword.conditional\n\n[\n  "break"\n  "continue"\n  "in"\n  "loop"\n  "while"\n] @keyword.repeat\n\n"for" @keyword\n\n(for_expression\n  "for" @keyword.repeat)\n\n; Operators\n[\n  "!"\n  "!="\n  "%"\n  "%="\n  "&"\n  "&&"\n  "&="\n  "*"\n  "*="\n  "+"\n  "+="\n  "-"\n  "-="\n  ".."\n  "..="\n  "..."\n  "/"\n  "/="\n  "<"\n  "<<"\n  "<<="\n  "<="\n  "="\n  "=="\n  ">"\n  ">="\n  ">>"\n  ">>="\n  "?"\n  "@"\n  "^"\n  "^="\n  "|"\n  "|="\n  "||"\n] @operator\n\n; Punctuation\n[\n  "("\n  ")"\n  "["\n  "]"\n  "{"\n  "}"\n] @punctuation.bracket\n\n(closure_parameters\n  "|" @punctuation.bracket)\n\n(type_arguments\n  [\n    "<"\n    ">"\n  ] @punctuation.bracket)\n\n(type_parameters\n  [\n    "<"\n    ">"\n  ] @punctuation.bracket)\n\n(bracketed_type\n  [\n    "<"\n    ">"\n  ] @punctuation.bracket)\n\n(for_lifetimes\n  [\n    "<"\n    ">"\n  ] @punctuation.bracket)\n\n[\n  ","\n  "."\n  ":"\n  "::"\n  ";"\n  "->"\n  "=>"\n] @punctuation.delimiter\n\n(attribute_item\n  "#" @punctuation.special)\n\n(inner_attribute_item\n  [\n    "!"\n    "#"\n  ] @punctuation.special)\n\n(macro_invocation\n  "!" @function.macro)\n\n(macro_invocation\n  macro: (identifier) @keyword.exception\n  "!" @keyword.exception\n  (#eq? @keyword.exception "panic"))\n\n(macro_invocation\n  macro: (identifier) @keyword.exception\n  "!" @keyword.exception\n  (#contains? @keyword.exception "assert"))\n\n(macro_invocation\n  macro: (identifier) @keyword.debug\n  "!" @keyword.debug\n  (#eq? @keyword.debug "dbg"))\n\n'}}]);