"use strict";(self.webpackChunkclient=self.webpackChunkclient||[]).push([[375],{4375:n=>{n.exports='(preproc_def\n  (preproc_arg) @variable)\n\n[\n  "default"\n  "enum"\n  "goto"\n  "asm"\n  "__asm__"\n] @keyword\n\n([\n  "struct"\n  "typedef"\n  "union"\n] @keyword (#set! "score" 2))\n\n[\n  "sizeof"\n  "offsetof"\n] @keyword.operator\n\n(alignof_expression\n  .\n  _ @keyword.operator)\n\n"return" @keyword.return\n\n[\n  "while"\n  "for"\n  "do"\n  "continue"\n  "break"\n] @keyword.repeat\n\n[\n  "if"\n  "else"\n  "case"\n  "switch"\n] @keyword.conditional\n\n[\n  "#if"\n  "#ifdef"\n  "#ifndef"\n  "#else"\n  "#elif"\n  "#endif"\n  "#elifdef"\n  "#elifndef"\n  (preproc_directive)\n] @keyword.directive\n\n"#define" @keyword.directive.define\n\n"#include" @keyword.import\n\n[\n  ";"\n  ":"\n  ","\n  "::"\n] @punctuation.delimiter\n\n"..." @punctuation.special\n\n[\n  "("\n  ")"\n  "["\n  "]"\n  "{"\n  "}"\n] @punctuation.bracket\n\n[\n  "="\n  "-"\n  "*"\n  "/"\n  "+"\n  "%"\n  "~"\n  "|"\n  "&"\n  "^"\n  "<<"\n  ">>"\n  "->"\n  "."\n  "<"\n  "<="\n  ">="\n  ">"\n  "=="\n  "!="\n  "!"\n  "&&"\n  "||"\n  "-="\n  "+="\n  "*="\n  "/="\n  "%="\n  "|="\n  "&="\n  "^="\n  ">>="\n  "<<="\n  "--"\n  "++"\n] @operator\n\n; Make sure the comma operator is given a highlight group after the comma\n; punctuator so the operator is highlighted properly.\n(comma_expression\n  "," @operator)\n\n[\n  (true)\n  (false)\n] @boolean\n\n(conditional_expression\n  [\n    "?"\n    ":"\n  ] @keyword.conditional.ternary)\n\n(string_literal) @string\n\n(system_lib_string) @string\n\n(escape_sequence) @string.escape\n\n(null) @constant.builtin\n\n(number_literal) @number\n\n(char_literal) @character\n\n((preproc_arg) @function.macro\n  (#set! "priority" 90))\n\n(preproc_defined) @function.macro\n\n((field_expression\n  (field_identifier) @property) @_parent\n  (#not-has-parent? @_parent template_method function_declarator call_expression))\n\n(field_designator) @property\n\n((field_identifier) @property\n  (#has-ancestor? @property field_declaration)\n  (#not-has-ancestor? @property function_declarator))\n\n(statement_identifier) @label\n\n[\n  (type_identifier)\n  (type_descriptor)\n] @type\n\n(storage_class_specifier) @keyword.storage\n\n[\n  (type_qualifier)\n  (gnu_asm_qualifier)\n  "__extension__"\n] @type.qualifier\n\n(linkage_specification\n  "extern" @keyword.storage)\n\n(type_definition\n  declarator: (type_identifier) @type.definition)\n\n(primitive_type) @type.builtin\n\n(sized_type_specifier\n  _ @type.builtin\n  type: _?)\n\n((identifier) @constant\n  (#lua-match? @constant "^[A-Z][A-Z0-9_]+$"))\n\n(preproc_def\n  (preproc_arg) @constant\n  (#lua-match? @constant "^[A-Z][A-Z0-9_]+$"))\n\n(enumerator\n  name: (identifier) @constant)\n\n(case_statement\n  value: (identifier) @constant)\n\n((identifier) @constant.builtin\n  ; format-ignore\n  (#any-of? @constant.builtin\n    "stderr" "stdin" "stdout"\n    "__FILE__" "__LINE__" "__DATE__" "__TIME__"\n    "__STDC__" "__STDC_VERSION__" "__STDC_HOSTED__"\n    "__cplusplus" "__OBJC__" "__ASSEMBLER__"\n    "__BASE_FILE__" "__FILE_NAME__" "__INCLUDE_LEVEL__"\n    "__TIMESTAMP__" "__clang__" "__clang_major__"\n    "__clang_minor__" "__clang_patchlevel__"\n    "__clang_version__" "__clang_literal_encoding__"\n    "__clang_wide_literal_encoding__"\n    "__FUNCTION__" "__func__" "__PRETTY_FUNCTION__"\n    "__VA_ARGS__" "__VA_OPT__"))\n\n(preproc_def\n  (preproc_arg) @constant.builtin\n  ; format-ignore\n  (#any-of? @constant.builtin\n    "stderr" "stdin" "stdout"\n    "__FILE__" "__LINE__" "__DATE__" "__TIME__"\n    "__STDC__" "__STDC_VERSION__" "__STDC_HOSTED__"\n    "__cplusplus" "__OBJC__" "__ASSEMBLER__"\n    "__BASE_FILE__" "__FILE_NAME__" "__INCLUDE_LEVEL__"\n    "__TIMESTAMP__" "__clang__" "__clang_major__"\n    "__clang_minor__" "__clang_patchlevel__"\n    "__clang_version__" "__clang_literal_encoding__"\n    "__clang_wide_literal_encoding__"\n    "__FUNCTION__" "__func__" "__PRETTY_FUNCTION__"\n    "__VA_ARGS__" "__VA_OPT__"))\n\n(attribute_specifier\n  (argument_list\n    (identifier) @variable.builtin))\n\n(attribute_specifier\n  (argument_list\n    (call_expression\n      function: (identifier) @variable.builtin)))\n\n((call_expression\n  function: (identifier) @function.builtin)\n  (#lua-match? @function.builtin "^__builtin_"))\n\n((call_expression\n  function: (identifier) @function.builtin)\n  (#has-ancestor? @function.builtin attribute_specifier))\n\n; Preproc def / undef\n(preproc_def\n  name: (_) @constant)\n\n(preproc_call\n  directive: (preproc_directive) @_u\n  argument: (_) @constant\n  (#eq? @_u "#undef"))\n\n(call_expression\n  function: (identifier) @function.call)\n\n(call_expression\n  function:\n    (field_expression\n      field: (field_identifier) @function.call))\n\n(function_declarator\n  declarator: (identifier) @function)\n\n(function_declarator\n  declarator:\n    (parenthesized_declarator\n      (pointer_declarator\n        declarator: (field_identifier) @function)))\n\n(preproc_function_def\n  name: (identifier) @function.macro)\n\n(comment) @comment @spell\n\n((comment) @comment.documentation\n  (#lua-match? @comment.documentation "^/[*][*][^*].*[*]/$"))\n\n; Parameters\n(parameter_declaration\n  declarator: (identifier) @variable.parameter)\n\n(parameter_declaration\n  declarator: (array_declarator) @variable.parameter)\n\n(parameter_declaration\n  declarator: (pointer_declarator) @variable.parameter)\n\n; K&R functions\n; To enable support for K&R functions,\n; add the following lines to your own query config and uncomment them.\n; They are commented out as they\'ll conflict with C++\n; Note that you\'ll need to have `; extends` at the top of your query file.\n;\n; (parameter_list (identifier) @variable.parameter)\n;\n; (function_definition\n;   declarator: _\n;   (declaration\n;     declarator: (identifier) @variable.parameter))\n;\n; (function_definition\n;   declarator: _\n;   (declaration\n;     declarator: (array_declarator) @variable.parameter))\n;\n; (function_definition\n;   declarator: _\n;   (declaration\n;     declarator: (pointer_declarator) @variable.parameter))\n(preproc_params\n  (identifier) @variable.parameter)\n\n[\n  "__attribute__"\n  "__declspec"\n  "__based"\n  "__cdecl"\n  "__clrcall"\n  "__stdcall"\n  "__fastcall"\n  "__thiscall"\n  "__vectorcall"\n  (ms_pointer_modifier)\n  (attribute_declaration)\n] @attribute\n\n'}}]);